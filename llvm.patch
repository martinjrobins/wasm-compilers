diff '--color=auto' -r -u llvm/clang/CMakeLists.txt build/llvm-src/clang/CMakeLists.txt
--- llvm/clang/CMakeLists.txt	2023-12-29 21:47:41.264640866 +0100
+++ build/llvm-src/clang/CMakeLists.txt	2024-01-02 03:15:13.625394909 +0100
@@ -421,8 +421,11 @@
 # If libstdc++ is statically linked, clang-repl needs to statically link libstdc++
 # itself, which is not possible in many platforms because of current limitations in
 # JIT stack. (more platforms need to be supported by JITLink)
-if(NOT LLVM_STATIC_LINK_CXX_STDLIB)
+# Moreover, clang-repl does not work on wasi.
+if(NOT LLVM_STATIC_LINK_CXX_STDLIB AND NOT WASI)
   set(HAVE_CLANG_REPL_SUPPORT ON)
+else()
+  set(HAVE_CLANG_REPL_SUPPORT OFF)
 endif()
 
 option(CLANG_ENABLE_ARCMT "Build ARCMT." ON)
diff '--color=auto' -r -u llvm/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h build/llvm-src/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
--- llvm/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h	2023-12-29 16:36:20.441395353 +0100
+++ build/llvm-src/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h	2024-01-02 03:15:13.625394909 +0100
@@ -16,6 +16,7 @@
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/ErrorOr.h"
 #include "llvm/Support/VirtualFileSystem.h"
+#include "llvm/Support/thread.h"
 #include <mutex>
 #include <optional>
 
@@ -36,7 +37,7 @@
   std::unique_ptr<llvm::MemoryBuffer> Original;
 
   /// The mutex that must be locked before mutating directive tokens.
-  std::mutex ValueLock;
+  llvm::mutex ValueLock;
   SmallVector<dependency_directives_scan::Token, 10> DepDirectiveTokens;
   /// Accessor to the directive tokens that's atomic to avoid data races.
   /// \p CachedFileContents has ownership of the pointer.
@@ -152,7 +153,7 @@
 public:
   struct CacheShard {
     /// The mutex that needs to be locked before mutation of any member.
-    mutable std::mutex CacheLock;
+    mutable llvm::mutex CacheLock;
 
     /// Map from filenames to cached entries.
     llvm::StringMap<const CachedFileSystemEntry *, llvm::BumpPtrAllocator>
diff '--color=auto' -r -u llvm/clang/lib/CMakeLists.txt build/llvm-src/clang/lib/CMakeLists.txt
--- llvm/clang/lib/CMakeLists.txt	2023-12-29 16:36:20.484397720 +0100
+++ build/llvm-src/clang/lib/CMakeLists.txt	2024-01-02 03:15:13.625394909 +0100
@@ -28,5 +28,7 @@
 if(CLANG_INCLUDE_TESTS)
   add_subdirectory(Testing)
 endif()
+if(NOT WASI)
 add_subdirectory(Interpreter)
+endif()
 add_subdirectory(Support)
diff '--color=auto' -r -u llvm/clang/lib/Frontend/PrecompiledPreamble.cpp build/llvm-src/clang/lib/Frontend/PrecompiledPreamble.cpp
--- llvm/clang/lib/Frontend/PrecompiledPreamble.cpp	2023-12-29 16:36:20.538400692 +0100
+++ build/llvm-src/clang/lib/Frontend/PrecompiledPreamble.cpp	2024-01-02 03:15:13.625394909 +0100
@@ -159,7 +159,7 @@
   void removeFile(StringRef File);
 
 private:
-  std::mutex Mutex;
+  llvm::mutex Mutex;
   llvm::StringSet<> Files;
 };
 
@@ -169,20 +169,20 @@
 }
 
 TemporaryFiles::~TemporaryFiles() {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   for (const auto &File : Files)
     llvm::sys::fs::remove(File.getKey());
 }
 
 void TemporaryFiles::addFile(StringRef File) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   auto IsInserted = Files.insert(File).second;
   (void)IsInserted;
   assert(IsInserted && "File has already been added");
 }
 
 void TemporaryFiles::removeFile(StringRef File) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   auto WasPresent = Files.erase(File);
   (void)WasPresent;
   assert(WasPresent && "File was not tracked");
diff '--color=auto' -r -u llvm/clang/lib/Tooling/AllTUsExecution.cpp build/llvm-src/clang/lib/Tooling/AllTUsExecution.cpp
--- llvm/clang/lib/Tooling/AllTUsExecution.cpp	2023-12-29 16:36:20.643406471 +0100
+++ build/llvm-src/clang/lib/Tooling/AllTUsExecution.cpp	2024-01-02 03:15:13.626394965 +0100
@@ -34,7 +34,7 @@
 class ThreadSafeToolResults : public ToolResults {
 public:
   void addResult(StringRef Key, StringRef Value) override {
-    std::unique_lock<std::mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(Mutex);
     Results.addResult(Key, Value);
   }
 
@@ -50,7 +50,7 @@
 
 private:
   InMemoryToolResults Results;
-  std::mutex Mutex;
+  llvm::mutex Mutex;
 };
 
 } // namespace
@@ -87,20 +87,20 @@
         "Only support executing exactly 1 action at this point.");
 
   std::string ErrorMsg;
-  std::mutex TUMutex;
+  llvm::mutex TUMutex;
   auto AppendError = [&](llvm::Twine Err) {
-    std::unique_lock<std::mutex> LockGuard(TUMutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(TUMutex);
     ErrorMsg += Err.str();
   };
 
   auto Log = [&](llvm::Twine Msg) {
-    std::unique_lock<std::mutex> LockGuard(TUMutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(TUMutex);
     llvm::errs() << Msg.str() << "\n";
   };
 
   std::vector<std::string> Files;
   llvm::Regex RegexFilter(Filter);
-  for (const auto& File : Compilations.getAllFiles()) {
+  for (const auto &File : Compilations.getAllFiles()) {
     if (RegexFilter.match(File))
       Files.push_back(File);
   }
@@ -108,7 +108,7 @@
   const std::string TotalNumStr = std::to_string(Files.size());
   unsigned Counter = 0;
   auto Count = [&]() {
-    std::unique_lock<std::mutex> LockGuard(TUMutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(TUMutex);
     return ++Counter;
   };
 
@@ -164,7 +164,7 @@
           "[AllTUsToolExecutorPlugin] Please provide a directory/file path in "
           "the compilation database.");
     return std::make_unique<AllTUsToolExecutor>(std::move(OptionsParser),
-                                                 ExecutorConcurrency);
+                                                ExecutorConcurrency);
   }
 };
 
diff '--color=auto' -r -u llvm/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp build/llvm-src/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp
--- llvm/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp	2023-12-29 21:47:41.424649691 +0100
+++ build/llvm-src/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp	2024-01-02 03:15:13.626394965 +0100
@@ -54,7 +54,7 @@
   if (Contents->DepDirectives.load())
     return EntryRef(Filename, Entry);
 
-  std::lock_guard<std::mutex> GuardLock(Contents->ValueLock);
+  llvm::lock_guard<llvm::mutex> GuardLock(Contents->ValueLock);
 
   // Double-checked locking.
   if (Contents->DepDirectives.load())
@@ -111,7 +111,7 @@
 DependencyScanningFilesystemSharedCache::CacheShard::findEntryByFilename(
     StringRef Filename) const {
   assert(llvm::sys::path::is_absolute_gnu(Filename));
-  std::lock_guard<std::mutex> LockGuard(CacheLock);
+  llvm::lock_guard<llvm::mutex> LockGuard(CacheLock);
   auto It = EntriesByFilename.find(Filename);
   return It == EntriesByFilename.end() ? nullptr : It->getValue();
 }
@@ -119,7 +119,7 @@
 const CachedFileSystemEntry *
 DependencyScanningFilesystemSharedCache::CacheShard::findEntryByUID(
     llvm::sys::fs::UniqueID UID) const {
-  std::lock_guard<std::mutex> LockGuard(CacheLock);
+  llvm::lock_guard<llvm::mutex> LockGuard(CacheLock);
   auto It = EntriesByUID.find(UID);
   return It == EntriesByUID.end() ? nullptr : It->getSecond();
 }
@@ -128,7 +128,7 @@
 DependencyScanningFilesystemSharedCache::CacheShard::
     getOrEmplaceEntryForFilename(StringRef Filename,
                                  llvm::ErrorOr<llvm::vfs::Status> Stat) {
-  std::lock_guard<std::mutex> LockGuard(CacheLock);
+  llvm::lock_guard<llvm::mutex> LockGuard(CacheLock);
   auto Insertion = EntriesByFilename.insert({Filename, nullptr});
   if (Insertion.second)
     Insertion.first->second =
@@ -140,7 +140,7 @@
 DependencyScanningFilesystemSharedCache::CacheShard::getOrEmplaceEntryForUID(
     llvm::sys::fs::UniqueID UID, llvm::vfs::Status Stat,
     std::unique_ptr<llvm::MemoryBuffer> Contents) {
-  std::lock_guard<std::mutex> LockGuard(CacheLock);
+  llvm::lock_guard<llvm::mutex> LockGuard(CacheLock);
   auto Insertion = EntriesByUID.insert({UID, nullptr});
   if (Insertion.second) {
     CachedFileContents *StoredContents = nullptr;
@@ -157,7 +157,7 @@
 DependencyScanningFilesystemSharedCache::CacheShard::
     getOrInsertEntryForFilename(StringRef Filename,
                                 const CachedFileSystemEntry &Entry) {
-  std::lock_guard<std::mutex> LockGuard(CacheLock);
+  llvm::lock_guard<llvm::mutex> LockGuard(CacheLock);
   return *EntriesByFilename.insert({Filename, &Entry}).first->getValue();
 }
 
diff '--color=auto' -r -u llvm/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp build/llvm-src/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp
--- llvm/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp	2023-12-29 21:47:41.498653772 +0100
+++ build/llvm-src/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp	2024-01-02 03:15:13.626394965 +0100
@@ -78,7 +78,7 @@
 static std::string CudaBinaryPath;
 
 /// Mutex lock to protect writes to shared TempFiles in parallel.
-static std::mutex TempFilesMutex;
+static llvm::mutex TempFilesMutex;
 
 /// Temporary files created by the linker wrapper.
 static std::list<SmallString<128>> TempFiles;
@@ -200,7 +200,7 @@
 
 /// Get a temporary filename suitable for output.
 Expected<StringRef> createOutputFile(const Twine &Prefix, StringRef Extension) {
-  std::scoped_lock<decltype(TempFilesMutex)> Lock(TempFilesMutex);
+  llvm::scoped_lock<decltype(TempFilesMutex)> Lock(TempFilesMutex);
   SmallString<128> OutputFile;
   if (SaveTemps) {
     (Prefix + "." + Extension).toNullTerminatedStringRef(OutputFile);
@@ -1074,7 +1074,7 @@
     InputsForTarget.emplace_back(std::move(Input));
   InputMap.clear();
 
-  std::mutex ImageMtx;
+  llvm::mutex ImageMtx;
   DenseMap<OffloadKind, SmallVector<OffloadingImage>> Images;
   auto Err = parallelForEachError(InputsForTarget, [&](auto &Input) -> Error {
     llvm::TimeTraceScope TimeScope("Link device input");
@@ -1126,7 +1126,7 @@
           return createFileError(*OutputOrErr, EC);
       }
 
-      std::scoped_lock<decltype(ImageMtx)> Guard(ImageMtx);
+      llvm::scoped_lock<decltype(ImageMtx)> Guard(ImageMtx);
       OffloadingImage TheImage{};
       TheImage.TheImageKind =
           Args.hasArg(OPT_embed_bitcode) ? IMG_Bitcode : IMG_Object;
diff '--color=auto' -r -u llvm/clang/tools/clang-scan-deps/ClangScanDeps.cpp build/llvm-src/clang/tools/clang-scan-deps/ClangScanDeps.cpp
--- llvm/clang/tools/clang-scan-deps/ClangScanDeps.cpp	2023-12-29 21:47:41.498653772 +0100
+++ build/llvm-src/clang/tools/clang-scan-deps/ClangScanDeps.cpp	2024-01-02 03:15:13.626394965 +0100
@@ -28,10 +28,9 @@
 #include "llvm/Support/ThreadPool.h"
 #include "llvm/Support/Threading.h"
 #include "llvm/Support/Timer.h"
+#include "llvm/Support/thread.h"
 #include "llvm/TargetParser/Host.h"
-#include <mutex>
 #include <optional>
-#include <thread>
 
 #include "Opts.inc"
 
@@ -233,13 +232,13 @@
 public:
   SharedStream(raw_ostream &OS) : OS(OS) {}
   void applyLocked(llvm::function_ref<void(raw_ostream &OS)> Fn) {
-    std::unique_lock<std::mutex> LockGuard(Lock);
+    llvm::unique_lock<llvm::mutex> LockGuard(Lock);
     Fn(OS);
     OS.flush();
   }
 
 private:
-  std::mutex Lock;
+  llvm::mutex Lock;
   raw_ostream &OS;
 };
 
@@ -262,7 +261,7 @@
     const std::string &ClangBinaryName =
         std::string(llvm::sys::path::filename(ClangBinaryPath));
 
-    std::unique_lock<std::mutex> LockGuard(CacheLock);
+    llvm::unique_lock<llvm::mutex> LockGuard(CacheLock);
     const auto &CachedResourceDir = Cache.find(ClangBinaryPath);
     if (CachedResourceDir != Cache.end())
       return CachedResourceDir->second;
@@ -303,7 +302,7 @@
 
 private:
   std::map<std::string, std::string> Cache;
-  std::mutex CacheLock;
+  llvm::mutex CacheLock;
 };
 
 } // end anonymous namespace
@@ -375,7 +374,7 @@
   void mergeDeps(ModuleDepsGraph Graph, size_t InputIndex) {
     std::vector<ModuleDeps *> NewMDs;
     {
-      std::unique_lock<std::mutex> ul(Lock);
+      llvm::unique_lock<llvm::mutex> ul(Lock);
       for (const ModuleDeps &MD : Graph) {
         auto I = Modules.find({MD.ID, 0});
         if (I != Modules.end()) {
@@ -530,7 +529,7 @@
     std::vector<Command> Commands;
   };
 
-  std::mutex Lock;
+  llvm::mutex Lock;
   std::unordered_map<IndexedModuleID, ModuleDeps, IndexedModuleID::Hasher>
       Modules;
   std::vector<InputDeps> Inputs;
@@ -615,7 +614,7 @@
   }
 
   void addRules(P1689Rule &Rule) {
-    std::unique_lock<std::mutex> LockGuard(Lock);
+    llvm::unique_lock<llvm::mutex> LockGuard(Lock);
     Rules.push_back(Rule);
   }
 
@@ -635,7 +634,7 @@
     }
   }
 
-  std::mutex Lock;
+  llvm::mutex Lock;
   std::vector<P1689Rule> Rules;
 };
 
@@ -881,10 +880,10 @@
   std::optional<FullDeps> FD;
   P1689Deps PD;
 
-  std::mutex Lock;
+  llvm::mutex Lock;
   size_t Index = 0;
   auto GetNextInputIndex = [&]() -> std::optional<size_t> {
-    std::unique_lock<std::mutex> LockGuard(Lock);
+    llvm::unique_lock<llvm::mutex> LockGuard(Lock);
     if (Index < Inputs.size())
       return Index++;
     return {};
@@ -944,13 +943,13 @@
 
           if (!MakeformatOutputPath.empty() && !MakeformatOutput.empty() &&
               !HadErrors) {
-            static std::mutex Lock;
+            static llvm::mutex Lock;
             // With compilation database, we may open different files
             // concurrently or we may write the same file concurrently. So we
             // use a map here to allow multiple compile commands to write to the
             // same file. Also we need a lock here to avoid data race.
             static llvm::StringMap<llvm::raw_fd_ostream> OSs;
-            std::unique_lock<std::mutex> LockGuard(Lock);
+            llvm::unique_lock<llvm::mutex> LockGuard(Lock);
 
             auto OSIter = OSs.find(MakeformatOutputPath);
             if (OSIter == OSs.end()) {
diff '--color=auto' -r -u llvm/clang/tools/libclang/CIndex.cpp build/llvm-src/clang/tools/libclang/CIndex.cpp
--- llvm/clang/tools/libclang/CIndex.cpp	2023-12-29 21:47:41.500653882 +0100
+++ build/llvm-src/clang/tools/libclang/CIndex.cpp	2024-01-02 03:15:13.627395020 +0100
@@ -2204,8 +2204,8 @@
   void VisitOMPMaskedTaskLoopDirective(const OMPMaskedTaskLoopDirective *D);
   void
   VisitOMPMasterTaskLoopSimdDirective(const OMPMasterTaskLoopSimdDirective *D);
-  void VisitOMPMaskedTaskLoopSimdDirective(
-      const OMPMaskedTaskLoopSimdDirective *D);
+  void
+  VisitOMPMaskedTaskLoopSimdDirective(const OMPMaskedTaskLoopSimdDirective *D);
   void VisitOMPParallelMasterTaskLoopDirective(
       const OMPParallelMasterTaskLoopDirective *D);
   void VisitOMPParallelMaskedTaskLoopDirective(
@@ -2735,8 +2735,7 @@
 void OMPClauseEnqueue::VisitOMPDoacrossClause(const OMPDoacrossClause *C) {
   VisitOMPClauseList(C);
 }
-void OMPClauseEnqueue::VisitOMPXAttributeClause(const OMPXAttributeClause *C) {
-}
+void OMPClauseEnqueue::VisitOMPXAttributeClause(const OMPXAttributeClause *C) {}
 void OMPClauseEnqueue::VisitOMPXBareClause(const OMPXBareClause *C) {}
 
 } // namespace
@@ -9650,10 +9649,10 @@
   return *this;
 }
 
-static llvm::ManagedStatic<std::mutex> LoggingMutex;
+static llvm::ManagedStatic<llvm::mutex> LoggingMutex;
 
 cxindex::Logger::~Logger() {
-  std::lock_guard<std::mutex> L(*LoggingMutex);
+  llvm::lock_guard<llvm::mutex> L(*LoggingMutex);
 
   static llvm::TimeRecord sBeginTR = llvm::TimeRecord::getCurrentTime();
 
diff '--color=auto' -r -u llvm/clang/tools/libclang/Indexing.cpp build/llvm-src/clang/tools/libclang/Indexing.cpp
--- llvm/clang/tools/libclang/Indexing.cpp	2023-12-29 16:36:21.646461676 +0100
+++ build/llvm-src/clang/tools/libclang/Indexing.cpp	2024-01-02 03:15:13.627395020 +0100
@@ -71,6 +71,7 @@
   llvm::sys::fs::UniqueID UniqueID;
   time_t ModTime;
   unsigned Offset;
+
 public:
   PPRegion() : UniqueID(0, 0), ModTime(), Offset() {}
   PPRegion(llvm::sys::fs::UniqueID UniqueID, unsigned offset, time_t modTime)
@@ -92,30 +93,29 @@
 
 namespace llvm {
 
-  template <>
-  struct DenseMapInfo<PPRegion> {
-    static inline PPRegion getEmptyKey() {
-      return PPRegion(llvm::sys::fs::UniqueID(0, 0), unsigned(-1), 0);
-    }
-    static inline PPRegion getTombstoneKey() {
-      return PPRegion(llvm::sys::fs::UniqueID(0, 0), unsigned(-2), 0);
-    }
-
-    static unsigned getHashValue(const PPRegion &S) {
-      llvm::FoldingSetNodeID ID;
-      const llvm::sys::fs::UniqueID &UniqueID = S.getUniqueID();
-      ID.AddInteger(UniqueID.getFile());
-      ID.AddInteger(UniqueID.getDevice());
-      ID.AddInteger(S.getOffset());
-      ID.AddInteger(S.getModTime());
-      return ID.ComputeHash();
-    }
+template <> struct DenseMapInfo<PPRegion> {
+  static inline PPRegion getEmptyKey() {
+    return PPRegion(llvm::sys::fs::UniqueID(0, 0), unsigned(-1), 0);
+  }
+  static inline PPRegion getTombstoneKey() {
+    return PPRegion(llvm::sys::fs::UniqueID(0, 0), unsigned(-2), 0);
+  }
+
+  static unsigned getHashValue(const PPRegion &S) {
+    llvm::FoldingSetNodeID ID;
+    const llvm::sys::fs::UniqueID &UniqueID = S.getUniqueID();
+    ID.AddInteger(UniqueID.getFile());
+    ID.AddInteger(UniqueID.getDevice());
+    ID.AddInteger(S.getOffset());
+    ID.AddInteger(S.getModTime());
+    return ID.ComputeHash();
+  }
 
-    static bool isEqual(const PPRegion &LHS, const PPRegion &RHS) {
-      return LHS == RHS;
-    }
-  };
-}
+  static bool isEqual(const PPRegion &LHS, const PPRegion &RHS) {
+    return LHS == RHS;
+  }
+};
+} // namespace llvm
 
 namespace {
 
@@ -123,19 +123,19 @@
 ///
 /// Is thread-safe.
 class ThreadSafeParsedRegions {
-  mutable std::mutex Mutex;
+  mutable llvm::mutex Mutex;
   llvm::DenseSet<PPRegion> ParsedRegions;
 
 public:
   ~ThreadSafeParsedRegions() = default;
 
   llvm::DenseSet<PPRegion> getParsedRegions() const {
-    std::lock_guard<std::mutex> MG(Mutex);
+    llvm::lock_guard<llvm::mutex> MG(Mutex);
     return ParsedRegions;
   }
 
   void addParsedRegions(ArrayRef<PPRegion> Regions) {
-    std::lock_guard<std::mutex> MG(Mutex);
+    llvm::lock_guard<llvm::mutex> MG(Mutex);
     ParsedRegions.insert(Regions.begin(), Regions.end());
   }
 };
@@ -240,10 +240,11 @@
 
 public:
   IndexPPCallbacks(Preprocessor &PP, CXIndexDataConsumer &dataConsumer)
-    : PP(PP), DataConsumer(dataConsumer), IsMainFileEntered(false) { }
+      : PP(PP), DataConsumer(dataConsumer), IsMainFileEntered(false) {}
 
   void FileChanged(SourceLocation Loc, FileChangeReason Reason,
-                 SrcMgr::CharacteristicKind FileType, FileID PrevFID) override {
+                   SrcMgr::CharacteristicKind FileType,
+                   FileID PrevFID) override {
     if (IsMainFileEntered)
       return;
 
@@ -263,10 +264,11 @@
                           OptionalFileEntryRef File, StringRef SearchPath,
                           StringRef RelativePath, const Module *Imported,
                           SrcMgr::CharacteristicKind FileType) override {
-    bool isImport = (IncludeTok.is(tok::identifier) &&
-            IncludeTok.getIdentifierInfo()->getPPKeywordID() == tok::pp_import);
+    bool isImport =
+        (IncludeTok.is(tok::identifier) &&
+         IncludeTok.getIdentifierInfo()->getPPKeywordID() == tok::pp_import);
     DataConsumer.ppIncludedFile(HashLoc, FileName, File, isImport, IsAngled,
-                            Imported);
+                                Imported);
   }
 
   /// MacroDefined - This hook is called whenever a macro definition is seen.
@@ -274,8 +276,7 @@
 
   /// MacroUndefined - This hook is called whenever a macro #undef is seen.
   /// MI is released immediately following this callback.
-  void MacroUndefined(const Token &MacroNameTok,
-                      const MacroDefinition &MD,
+  void MacroUndefined(const Token &MacroNameTok, const MacroDefinition &MD,
                       const MacroDirective *UD) override {}
 
   /// MacroExpands - This is called by when a macro invocation is found.
@@ -317,8 +318,8 @@
 
 class CaptureDiagnosticConsumer : public DiagnosticConsumer {
   SmallVector<StoredDiagnostic, 4> Errors;
-public:
 
+public:
   void HandleDiagnostic(DiagnosticsEngine::Level level,
                         const Diagnostic &Info) override {
     if (level >= DiagnosticsEngine::Error)
@@ -457,8 +458,8 @@
 
   IndexerCallbacks CB;
   memset(&CB, 0, sizeof(CB));
-  unsigned ClientCBSize = index_callbacks_size < sizeof(CB)
-                                  ? index_callbacks_size : sizeof(CB);
+  unsigned ClientCBSize =
+      index_callbacks_size < sizeof(CB) ? index_callbacks_size : sizeof(CB);
   memcpy(&CB, client_index_callbacks, ClientCBSize);
 
   IndexSessionData *IdxSession = static_cast<IndexSessionData *>(cxIdxAction);
@@ -478,23 +479,23 @@
     CaptureDiag = new CaptureDiagnosticConsumer();
 
   // Configure the diagnostics.
-  IntrusiveRefCntPtr<DiagnosticsEngine>
-    Diags(CompilerInstance::createDiagnostics(new DiagnosticOptions,
-                                              CaptureDiag,
-                                              /*ShouldOwnClient=*/true));
+  IntrusiveRefCntPtr<DiagnosticsEngine> Diags(
+      CompilerInstance::createDiagnostics(new DiagnosticOptions, CaptureDiag,
+                                          /*ShouldOwnClient=*/true));
 
   // Recover resources if we crash before exiting this function.
-  llvm::CrashRecoveryContextCleanupRegistrar<DiagnosticsEngine,
-    llvm::CrashRecoveryContextReleaseRefCleanup<DiagnosticsEngine> >
-    DiagCleanup(Diags.get());
+  llvm::CrashRecoveryContextCleanupRegistrar<
+      DiagnosticsEngine,
+      llvm::CrashRecoveryContextReleaseRefCleanup<DiagnosticsEngine>>
+      DiagCleanup(Diags.get());
 
   std::unique_ptr<std::vector<const char *>> Args(
       new std::vector<const char *>());
 
   // Recover resources if we crash before exiting this method.
-  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<const char*> >
-    ArgsCleanup(Args.get());
-  
+  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<const char *>>
+      ArgsCleanup(Args.get());
+
   Args->insert(Args->end(), command_line_args,
                command_line_args + num_command_line_args);
 
@@ -541,7 +542,7 @@
 
   // Since libclang is primarily used by batch tools dealing with
   // (often very broken) source code, where spell-checking can have a
-  // significant negative impact on performance (particularly when 
+  // significant negative impact on performance (particularly when
   // precompiled headers are involved), we disable it.
   CInvok->getLangOpts().SpellChecking = false;
 
@@ -562,33 +563,31 @@
       new CXTUOwner(MakeCXTranslationUnit(CXXIdx, std::move(Unit))));
 
   // Recover resources if we crash before exiting this method.
-  llvm::CrashRecoveryContextCleanupRegistrar<CXTUOwner>
-    CXTUCleanup(CXTU.get());
+  llvm::CrashRecoveryContextCleanupRegistrar<CXTUOwner> CXTUCleanup(CXTU.get());
 
   // Enable the skip-parsed-bodies optimization only for C++; this may be
   // revisited.
   bool SkipBodies = (index_options & CXIndexOpt_SkipParsedBodiesInSession) &&
-      CInvok->getLangOpts().CPlusPlus;
+                    CInvok->getLangOpts().CPlusPlus;
   if (SkipBodies)
     CInvok->getFrontendOpts().SkipFunctionBodies = true;
 
-  auto DataConsumer =
-    std::make_shared<CXIndexDataConsumer>(client_data, CB, index_options,
-                                          CXTU->getTU());
+  auto DataConsumer = std::make_shared<CXIndexDataConsumer>(
+      client_data, CB, index_options, CXTU->getTU());
   auto IndexAction = std::make_unique<IndexingFrontendAction>(
       DataConsumer, getIndexingOptionsFromCXOptions(index_options),
       SkipBodies ? IdxSession->SkipBodyData.get() : nullptr);
 
   // Recover resources if we crash before exiting this method.
-  llvm::CrashRecoveryContextCleanupRegistrar<FrontendAction>
-    IndexActionCleanup(IndexAction.get());
+  llvm::CrashRecoveryContextCleanupRegistrar<FrontendAction> IndexActionCleanup(
+      IndexAction.get());
 
   bool Persistent = requestedToGetTU;
   bool OnlyLocalDecls = false;
   bool PrecompilePreamble = false;
   bool CreatePreambleOnFirstParse = false;
   bool CacheCodeCompletionResults = false;
-  PreprocessorOptions &PPOpts = CInvok->getPreprocessorOpts(); 
+  PreprocessorOptions &PPOpts = CInvok->getPreprocessorOpts();
   PPOpts.AllowPCHWithCompilerErrors = true;
 
   if (requestedToGetTU) {
@@ -597,8 +596,8 @@
     CreatePreambleOnFirstParse =
         TU_options & CXTranslationUnit_CreatePreambleOnFirstParse;
     // FIXME: Add a flag for modules.
-    CacheCodeCompletionResults
-      = TU_options & CXTranslationUnit_CacheCompletionResults;
+    CacheCodeCompletionResults =
+        TU_options & CXTranslationUnit_CacheCompletionResults;
   }
 
   if (TU_options & CXTranslationUnit_DetailedPreprocessingRecord) {
@@ -638,7 +637,8 @@
 // clang_indexTranslationUnit Implementation
 //===----------------------------------------------------------------------===//
 
-static void indexPreprocessingRecord(ASTUnit &Unit, CXIndexDataConsumer &IdxCtx) {
+static void indexPreprocessingRecord(ASTUnit &Unit,
+                                     CXIndexDataConsumer &IdxCtx) {
   Preprocessor &PP = Unit.getPreprocessor();
   if (!PP.getPreprocessingRecord())
     return;
@@ -653,8 +653,7 @@
       // if the location points to such a file.
       if (isModuleFile && Unit.isInMainFileID(Loc))
         Loc = SourceLocation();
-      IdxCtx.ppIncludedFile(Loc, ID->getFileName(),
-                            ID->getFile(),
+      IdxCtx.ppIncludedFile(Loc, ID->getFileName(), ID->getFile(),
                             ID->getKind() == InclusionDirective::Import,
                             !ID->wasInQuotes(), ID->importedModule());
     }
@@ -680,8 +679,8 @@
 
   IndexerCallbacks CB;
   memset(&CB, 0, sizeof(CB));
-  unsigned ClientCBSize = index_callbacks_size < sizeof(CB)
-                                  ? index_callbacks_size : sizeof(CB);
+  unsigned ClientCBSize =
+      index_callbacks_size < sizeof(CB) ? index_callbacks_size : sizeof(CB);
   memcpy(&CB, client_index_callbacks, ClientCBSize);
 
   CXIndexDataConsumer DataConsumer(client_data, CB, index_options, TU);
@@ -709,7 +708,8 @@
   DataConsumer.startedTranslationUnit();
 
   indexPreprocessingRecord(*Unit, DataConsumer);
-  indexASTUnit(*Unit, DataConsumer, getIndexingOptionsFromCXOptions(index_options));
+  indexASTUnit(*Unit, DataConsumer,
+               getIndexingOptionsFromCXOptions(index_options));
   DataConsumer.indexDiagnostics();
 
   return CXError_Success;
@@ -729,8 +729,8 @@
     return nullptr;
 
   const DeclInfo *DI = static_cast<const DeclInfo *>(DInfo);
-  if (const ObjCContainerDeclInfo *
-        ContInfo = dyn_cast<ObjCContainerDeclInfo>(DI))
+  if (const ObjCContainerDeclInfo *ContInfo =
+          dyn_cast<ObjCContainerDeclInfo>(DI))
     return &ContInfo->ObjCContDeclInfo;
 
   return nullptr;
@@ -742,21 +742,20 @@
     return nullptr;
 
   const DeclInfo *DI = static_cast<const DeclInfo *>(DInfo);
-  if (const ObjCInterfaceDeclInfo *
-        InterInfo = dyn_cast<ObjCInterfaceDeclInfo>(DI))
+  if (const ObjCInterfaceDeclInfo *InterInfo =
+          dyn_cast<ObjCInterfaceDeclInfo>(DI))
     return &InterInfo->ObjCInterDeclInfo;
 
   return nullptr;
 }
 
 const CXIdxObjCCategoryDeclInfo *
-clang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo *DInfo){
+clang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo *DInfo) {
   if (!DInfo)
     return nullptr;
 
   const DeclInfo *DI = static_cast<const DeclInfo *>(DInfo);
-  if (const ObjCCategoryDeclInfo *
-        CatInfo = dyn_cast<ObjCCategoryDeclInfo>(DI))
+  if (const ObjCCategoryDeclInfo *CatInfo = dyn_cast<ObjCCategoryDeclInfo>(DI))
     return &CatInfo->ObjCCatDeclInfo;
 
   return nullptr;
@@ -768,13 +767,12 @@
     return nullptr;
 
   const DeclInfo *DI = static_cast<const DeclInfo *>(DInfo);
-  
-  if (const ObjCInterfaceDeclInfo *
-        InterInfo = dyn_cast<ObjCInterfaceDeclInfo>(DI))
+
+  if (const ObjCInterfaceDeclInfo *InterInfo =
+          dyn_cast<ObjCInterfaceDeclInfo>(DI))
     return InterInfo->ObjCInterDeclInfo.protocols;
-  
-  if (const ObjCProtocolDeclInfo *
-        ProtInfo = dyn_cast<ObjCProtocolDeclInfo>(DI))
+
+  if (const ObjCProtocolDeclInfo *ProtInfo = dyn_cast<ObjCProtocolDeclInfo>(DI))
     return &ProtInfo->ObjCProtoRefListInfo;
 
   if (const ObjCCategoryDeclInfo *CatInfo = dyn_cast<ObjCCategoryDeclInfo>(DI))
@@ -801,8 +799,8 @@
     return nullptr;
 
   const AttrInfo *DI = static_cast<const AttrInfo *>(AInfo);
-  if (const IBOutletCollectionInfo *
-        IBInfo = dyn_cast<IBOutletCollectionInfo>(DI))
+  if (const IBOutletCollectionInfo *IBInfo =
+          dyn_cast<IBOutletCollectionInfo>(DI))
     return &IBInfo->IBCollInfo;
 
   return nullptr;
@@ -860,17 +858,14 @@
     delete static_cast<IndexSessionData *>(idxAction);
 }
 
-int clang_indexSourceFile(CXIndexAction idxAction,
-                          CXClientData client_data,
+int clang_indexSourceFile(CXIndexAction idxAction, CXClientData client_data,
                           IndexerCallbacks *index_callbacks,
-                          unsigned index_callbacks_size,
-                          unsigned index_options,
+                          unsigned index_callbacks_size, unsigned index_options,
                           const char *source_filename,
-                          const char * const *command_line_args,
+                          const char *const *command_line_args,
                           int num_command_line_args,
                           struct CXUnsavedFile *unsaved_files,
-                          unsigned num_unsaved_files,
-                          CXTranslationUnit *out_TU,
+                          unsigned num_unsaved_files, CXTranslationUnit *out_TU,
                           unsigned TU_options) {
   SmallVector<const char *, 4> Args;
   Args.push_back("clang");
@@ -909,7 +904,8 @@
   llvm::CrashRecoveryContext CRC;
 
   if (!RunSafely(CRC, IndexSourceFileImpl)) {
-    fprintf(stderr, "libclang: crash detected during indexing source file: {\n");
+    fprintf(stderr,
+            "libclang: crash detected during indexing source file: {\n");
     fprintf(stderr, "  'source_filename' : '%s'\n", source_filename);
     fprintf(stderr, "  'command_line_args' : [");
     for (int i = 0; i != num_command_line_args; ++i) {
@@ -928,7 +924,7 @@
     fprintf(stderr, "],\n");
     fprintf(stderr, "  'options' : %d,\n", TU_options);
     fprintf(stderr, "}\n");
-    
+
     return 1;
   } else if (getenv("LIBCLANG_RESOURCE_USAGE")) {
     if (out_TU)
@@ -942,11 +938,8 @@
                                CXClientData client_data,
                                IndexerCallbacks *index_callbacks,
                                unsigned index_callbacks_size,
-                               unsigned index_options,
-                               CXTranslationUnit TU) {
-  LOG_FUNC_SECTION {
-    *Log << TU;
-  }
+                               unsigned index_options, CXTranslationUnit TU) {
+  LOG_FUNC_SECTION { *Log << TU; }
 
   CXErrorCode result;
   auto IndexTranslationUnitImpl = [=, &result]() {
@@ -959,7 +952,7 @@
 
   if (!RunSafely(CRC, IndexTranslationUnitImpl)) {
     fprintf(stderr, "libclang: crash detected during indexing TU\n");
-    
+
     return 1;
   }
 
@@ -967,23 +960,26 @@
 }
 
 void clang_indexLoc_getFileLocation(CXIdxLoc location,
-                                    CXIdxClientFile *indexFile,
-                                    CXFile *file,
-                                    unsigned *line,
-                                    unsigned *column,
+                                    CXIdxClientFile *indexFile, CXFile *file,
+                                    unsigned *line, unsigned *column,
                                     unsigned *offset) {
-  if (indexFile) *indexFile = nullptr;
-  if (file)   *file = nullptr;
-  if (line)   *line = 0;
-  if (column) *column = 0;
-  if (offset) *offset = 0;
+  if (indexFile)
+    *indexFile = nullptr;
+  if (file)
+    *file = nullptr;
+  if (line)
+    *line = 0;
+  if (column)
+    *column = 0;
+  if (offset)
+    *offset = 0;
 
   SourceLocation Loc = SourceLocation::getFromRawEncoding(location.int_data);
   if (!location.ptr_data[0] || Loc.isInvalid())
     return;
 
   CXIndexDataConsumer &DataConsumer =
-      *static_cast<CXIndexDataConsumer*>(location.ptr_data[0]);
+      *static_cast<CXIndexDataConsumer *>(location.ptr_data[0]);
   DataConsumer.translateLoc(Loc, indexFile, file, line, column, offset);
 }
 
@@ -993,6 +989,6 @@
     return clang_getNullLocation();
 
   CXIndexDataConsumer &DataConsumer =
-      *static_cast<CXIndexDataConsumer*>(location.ptr_data[0]);
+      *static_cast<CXIndexDataConsumer *>(location.ptr_data[0]);
   return cxloc::translateSourceLocation(DataConsumer.getASTContext(), Loc);
 }
diff '--color=auto' -r -u llvm/clang-tools-extra/clang-doc/tool/ClangDocMain.cpp build/llvm-src/clang-tools-extra/clang-doc/tool/ClangDocMain.cpp
--- llvm/clang-tools-extra/clang-doc/tool/ClangDocMain.cpp	2023-12-29 16:36:20.201382144 +0100
+++ build/llvm-src/clang-tools-extra/clang-doc/tool/ClangDocMain.cpp	2024-01-02 03:15:13.627395020 +0100
@@ -136,7 +136,7 @@
   std::error_code OK;
 
   const char *Overview =
-    R"(Generates documentation from source code and comments.
+      R"(Generates documentation from source code and comments.
 
 Example usage for files without flags (default):
 
@@ -264,13 +264,13 @@
 
       // Add a reference to this Info in the Index
       {
-        std::lock_guard<llvm::sys::Mutex> Guard(IndexMutex);
+        llvm::lock_guard<llvm::sys::Mutex> Guard(IndexMutex);
         clang::doc::Generator::addInfoToIndex(CDCtx.Idx, Reduced.get().get());
       }
 
       // Save in the result map (needs a lock due to threaded access).
       {
-        std::lock_guard<llvm::sys::Mutex> Guard(USRToInfoMutex);
+        llvm::lock_guard<llvm::sys::Mutex> Guard(USRToInfoMutex);
         USRToInfo[Group.getKey()] = std::move(Reduced.get());
       }
     });
diff '--color=auto' -r -u llvm/clang-tools-extra/clang-include-fixer/find-all-symbols/tool/FindAllSymbolsMain.cpp build/llvm-src/clang-tools-extra/clang-include-fixer/find-all-symbols/tool/FindAllSymbolsMain.cpp
--- llvm/clang-tools-extra/clang-include-fixer/find-all-symbols/tool/FindAllSymbolsMain.cpp	2023-12-29 16:36:20.203382254 +0100
+++ build/llvm-src/clang-tools-extra/clang-include-fixer/find-all-symbols/tool/FindAllSymbolsMain.cpp	2024-01-02 03:15:13.627395020 +0100
@@ -78,10 +78,10 @@
 bool Merge(llvm::StringRef MergeDir, llvm::StringRef OutputFile) {
   std::error_code EC;
   SymbolInfo::SignalMap Symbols;
-  std::mutex SymbolMutex;
+  llvm::mutex SymbolMutex;
   auto AddSymbols = [&](ArrayRef<SymbolAndSignals> NewSymbols) {
     // Synchronize set accesses.
-    std::unique_lock<std::mutex> LockGuard(SymbolMutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(SymbolMutex);
     for (const auto &Symbol : NewSymbols) {
       Symbols[Symbol.Symbol] += Symbol.Signals;
     }
@@ -124,8 +124,8 @@
   return true;
 }
 
-} // namespace clang
 } // namespace find_all_symbols
+} // namespace clang
 
 int main(int argc, const char **argv) {
   auto ExpectedParser =
diff '--color=auto' -r -u llvm/clang-tools-extra/clang-include-fixer/SymbolIndexManager.h build/llvm-src/clang-tools-extra/clang-include-fixer/SymbolIndexManager.h
--- llvm/clang-tools-extra/clang-include-fixer/SymbolIndexManager.h	2023-12-29 16:36:20.202382199 +0100
+++ build/llvm-src/clang-tools-extra/clang-include-fixer/SymbolIndexManager.h	2024-01-02 03:15:13.627395020 +0100
@@ -12,15 +12,14 @@
 #include "SymbolIndex.h"
 #include "find-all-symbols/SymbolInfo.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/Support/thread.h"
 
 #ifdef _MSC_VER
 // Disable warnings from ppltasks.h transitively included by <future>.
 #pragma warning(push)
-#pragma warning(disable:4530)
+#pragma warning(disable : 4530)
 #endif
 
-#include <future>
-
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
@@ -34,11 +33,11 @@
 public:
   void addSymbolIndex(std::function<std::unique_ptr<SymbolIndex>()> F) {
 #if LLVM_ENABLE_THREADS
-    auto Strategy = std::launch::async;
+    auto Strategy = llvm::launch::async;
 #else
-    auto Strategy = std::launch::deferred;
+    auto Strategy = llvm::launch::deferred;
 #endif
-    SymbolIndices.push_back(std::async(Strategy, F));
+    SymbolIndices.push_back(llvm::async(Strategy, F));
   }
 
   /// Search for header files to be included for an identifier.
@@ -56,7 +55,7 @@
          llvm::StringRef FileName = "") const;
 
 private:
-  std::vector<std::shared_future<std::unique_ptr<SymbolIndex>>> SymbolIndices;
+  std::vector<llvm::shared_future<std::unique_ptr<SymbolIndex>>> SymbolIndices;
 };
 
 } // namespace include_fixer
Only in llvm/libcxx/include: .future.swp
diff '--color=auto' -r -u llvm/lld/COFF/Driver.cpp build/llvm-src/lld/COFF/Driver.cpp
--- llvm/lld/COFF/Driver.cpp	2023-12-29 21:47:41.708665354 +0100
+++ build/llvm-src/lld/COFF/Driver.cpp	2024-01-02 03:15:13.628395075 +0100
@@ -47,10 +47,10 @@
 #include "llvm/Support/TargetSelect.h"
 #include "llvm/Support/VirtualFileSystem.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/thread.h"
 #include "llvm/TargetParser/Triple.h"
 #include "llvm/ToolDrivers/llvm-lib/LibDriver.h"
 #include <algorithm>
-#include <future>
 #include <memory>
 #include <optional>
 #include <tuple>
@@ -128,18 +128,18 @@
 // (a limited resource on Windows) for the duration that the future is pending.
 using MBErrPair = std::pair<std::unique_ptr<MemoryBuffer>, std::error_code>;
 
-// Create a std::future that opens and maps a file using the best strategy for
+// Create a llvm::future that opens and maps a file using the best strategy for
 // the host platform.
-static std::future<MBErrPair> createFutureForFile(std::string path) {
+static llvm::future<MBErrPair> createFutureForFile(std::string path) {
 #if _WIN64
   // On Windows, file I/O is relatively slow so it is best to do this
   // asynchronously.  But 32-bit has issues with potentially launching tons
   // of threads
-  auto strategy = std::launch::async;
+  auto strategy = llvm::launch::async;
 #else
-  auto strategy = std::launch::deferred;
+  auto strategy = llvm::launch::deferred;
 #endif
-  return std::async(strategy, [=]() {
+  return llvm::async(strategy, [=]() {
     auto mbOrErr = MemoryBuffer::getFile(path, /*IsText=*/false,
                                          /*RequiresNullTerminator=*/false);
     if (!mbOrErr)
@@ -243,7 +243,7 @@
 }
 
 void LinkerDriver::enqueuePath(StringRef path, bool wholeArchive, bool lazy) {
-  auto future = std::make_shared<std::future<MBErrPair>>(
+  auto future = std::make_shared<llvm::future<MBErrPair>>(
       createFutureForFile(std::string(path)));
   std::string pathStr = std::string(path);
   enqueueTask([=]() {
@@ -345,7 +345,7 @@
             "could not get the filename for the member defining symbol " +
                 toCOFFString(ctx, sym));
   auto future =
-      std::make_shared<std::future<MBErrPair>>(createFutureForFile(childName));
+      std::make_shared<llvm::future<MBErrPair>>(createFutureForFile(childName));
   enqueueTask([=]() {
     auto mbOrErr = future->get();
     if (mbOrErr.second)
diff '--color=auto' -r -u llvm/lld/Common/ErrorHandler.cpp build/llvm-src/lld/Common/ErrorHandler.cpp
--- llvm/lld/Common/ErrorHandler.cpp	2023-12-29 16:36:22.526510111 +0100
+++ build/llvm-src/lld/Common/ErrorHandler.cpp	2024-01-02 03:15:13.628395075 +0100
@@ -46,7 +46,7 @@
 }
 
 void ErrorHandler::flushStreams() {
-  std::lock_guard<std::mutex> lock(mu);
+  llvm::lock_guard<llvm::mutex> lock(mu);
   outs().flush();
   errs().flush();
 }
@@ -172,16 +172,14 @@
     return std::string(logName);
 
   static std::regex regexes[] = {
-      std::regex(
-          R"(^undefined (?:\S+ )?symbol:.*\n)"
-          R"(>>> referenced by .+\((\S+):(\d+)\))"),
+      std::regex(R"(^undefined (?:\S+ )?symbol:.*\n)"
+                 R"(>>> referenced by .+\((\S+):(\d+)\))"),
       std::regex(
           R"(^undefined (?:\S+ )?symbol:.*\n>>> referenced by (\S+):(\d+))"),
       std::regex(R"(^undefined symbol:.*\n>>> referenced by (.*):)"),
       std::regex(
           R"(^duplicate symbol: .*\n>>> defined in (\S+)\n>>> defined in.*)"),
-      std::regex(
-          R"(^duplicate symbol: .*\n>>> defined at .+\((\S+):(\d+)\))"),
+      std::regex(R"(^duplicate symbol: .*\n>>> defined at .+\((\S+):(\d+)\))"),
       std::regex(R"(^duplicate symbol: .*\n>>> defined at (\S+):(\d+))"),
       std::regex(
           R"(.*\n>>> defined in .*\n>>> referenced by .+\((\S+):(\d+)\))"),
@@ -224,14 +222,14 @@
 void ErrorHandler::log(const Twine &msg) {
   if (!verbose || disableOutput)
     return;
-  std::lock_guard<std::mutex> lock(mu);
+  llvm::lock_guard<llvm::mutex> lock(mu);
   reportDiagnostic(logName, Colors::RESET, "", msg);
 }
 
 void ErrorHandler::message(const Twine &msg, llvm::raw_ostream &s) {
   if (disableOutput)
     return;
-  std::lock_guard<std::mutex> lock(mu);
+  llvm::lock_guard<llvm::mutex> lock(mu);
   s << msg << "\n";
   s.flush();
 }
@@ -245,7 +243,7 @@
   if (suppressWarnings)
     return;
 
-  std::lock_guard<std::mutex> lock(mu);
+  llvm::lock_guard<llvm::mutex> lock(mu);
   reportDiagnostic(getLocation(msg), Colors::MAGENTA, "warning", msg);
   sep = getSeparator(msg);
 }
@@ -269,7 +267,7 @@
 
   bool exit = false;
   {
-    std::lock_guard<std::mutex> lock(mu);
+    llvm::lock_guard<llvm::mutex> lock(mu);
 
     if (errorLimit == 0 || errorCount < errorLimit) {
       reportDiagnostic(getLocation(msg), Colors::RED, "error", msg);
diff '--color=auto' -r -u llvm/lld/Common/Filesystem.cpp build/llvm-src/lld/Common/Filesystem.cpp
--- llvm/lld/Common/Filesystem.cpp	2023-12-29 16:36:22.526510111 +0100
+++ build/llvm-src/lld/Common/Filesystem.cpp	2024-01-02 03:15:13.628395075 +0100
@@ -18,10 +18,10 @@
 #include "llvm/Support/Parallel.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/TimeProfiler.h"
+#include "llvm/Support/thread.h"
 #if LLVM_ON_UNIX
 #include <unistd.h>
 #endif
-#include <thread>
 
 using namespace llvm;
 using namespace lld;
@@ -91,12 +91,12 @@
     return;
 
   // close and therefore remove TempPath in background.
-  std::mutex m;
-  std::condition_variable cv;
+  llvm::mutex m;
+  llvm::condition_variable cv;
   bool started = false;
-  std::thread([&, fd] {
+  llvm::thread([&, fd] {
     {
-      std::lock_guard<std::mutex> l(m);
+      llvm::lock_guard<llvm::mutex> l(m);
       started = true;
       cv.notify_all();
     }
@@ -105,7 +105,7 @@
 
   // GLIBC 2.26 and earlier have race condition that crashes an entire process
   // if the main thread calls exit(2) while other thread is starting up.
-  std::unique_lock<std::mutex> l(m);
+  llvm::unique_lock<llvm::mutex> l(m);
   cv.wait(l, [&] { return started; });
 #endif
 }
diff '--color=auto' -r -u llvm/lld/ELF/InputFiles.cpp build/llvm-src/lld/ELF/InputFiles.cpp
--- llvm/lld/ELF/InputFiles.cpp	2023-12-29 21:47:41.711665519 +0100
+++ build/llvm-src/lld/ELF/InputFiles.cpp	2024-01-02 03:15:13.628395075 +0100
@@ -30,6 +30,7 @@
 #include "llvm/Support/RISCVAttributeParser.h"
 #include "llvm/Support/TarWriter.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/thread.h"
 #include <optional>
 
 using namespace llvm;
@@ -55,12 +56,12 @@
 
 // Returns "<internal>", "foo.a(bar.o)" or "baz.o".
 std::string lld::toString(const InputFile *f) {
-  static std::mutex mu;
+  static llvm::mutex mu;
   if (!f)
     return "<internal>";
 
   {
-    std::lock_guard<std::mutex> lock(mu);
+    llvm::lock_guard<llvm::mutex> lock(mu);
     if (f->toStringCache.empty()) {
       if (f->archiveName.empty())
         f->toStringCache = f->getName();
@@ -1173,7 +1174,7 @@
 // Called after all ObjFile::parse is called for all ObjFiles. This checks
 // duplicate symbols and may do symbol property merge in the future.
 template <class ELFT> void ObjFile<ELFT>::postParse() {
-  static std::mutex mu;
+  static llvm::mutex mu;
   ArrayRef<Elf_Sym> eSyms = this->getELFSyms<ELFT>();
   for (size_t i = firstGlobal, end = eSyms.size(); i != end; ++i) {
     const Elf_Sym &eSym = eSyms[i];
@@ -1214,7 +1215,7 @@
                          sym.getName());
       }
       if (sym.file == this) {
-        std::lock_guard<std::mutex> lock(mu);
+        llvm::lock_guard<llvm::mutex> lock(mu);
         ctx.nonPrevailingSyms.emplace_back(&sym, secIdx);
       }
       continue;
@@ -1227,7 +1228,7 @@
 
     if (sym.binding == STB_WEAK || binding == STB_WEAK)
       continue;
-    std::lock_guard<std::mutex> lock(mu);
+    llvm::lock_guard<llvm::mutex> lock(mu);
     ctx.duplicates.push_back({&sym, this, sec, eSym.st_value});
   }
 }
@@ -1678,9 +1679,10 @@
   llvm_unreachable("unknown visibility");
 }
 
-static void
-createBitcodeSymbol(Symbol *&sym, const std::vector<bool> &keptComdats,
-                    const lto::InputFile::Symbol &objSym, BitcodeFile &f) {
+static void createBitcodeSymbol(Symbol *&sym,
+                                const std::vector<bool> &keptComdats,
+                                const lto::InputFile::Symbol &objSym,
+                                BitcodeFile &f) {
   uint8_t binding = objSym.isWeak() ? STB_WEAK : STB_GLOBAL;
   uint8_t type = objSym.isTLS() ? STT_TLS : STT_NOTYPE;
   uint8_t visibility = mapVisibility(objSym.getVisibility());
diff '--color=auto' -r -u llvm/lld/ELF/InputSection.cpp build/llvm-src/lld/ELF/InputSection.cpp
--- llvm/lld/ELF/InputSection.cpp	2023-12-29 21:47:41.711665519 +0100
+++ build/llvm-src/lld/ELF/InputSection.cpp	2024-01-02 03:15:13.628395075 +0100
@@ -19,9 +19,9 @@
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/Compression.h"
 #include "llvm/Support/Endian.h"
+#include "llvm/Support/thread.h"
 #include "llvm/Support/xxhash.h"
 #include <algorithm>
-#include <mutex>
 #include <optional>
 #include <vector>
 
@@ -73,7 +73,7 @@
   // If SHF_COMPRESSED is set, parse the header. The legacy .zdebug format is no
   // longer supported.
   if (flags & SHF_COMPRESSED)
-    invokeELFT(parseCompressedHeader,);
+    invokeELFT(parseCompressedHeader, );
 }
 
 // Drop SHF_GROUP bit unless we are producing a re-linkable object file.
@@ -123,8 +123,8 @@
 void InputSectionBase::decompress() const {
   uint8_t *uncompressedBuf;
   {
-    static std::mutex mu;
-    std::lock_guard<std::mutex> lock(mu);
+    static llvm::mutex mu;
+    llvm::lock_guard<llvm::mutex> lock(mu);
     uncompressedBuf = bAlloc().Allocate<uint8_t>(size);
   }
 
@@ -1139,7 +1139,8 @@
     // conservative.
     if (Defined *d = dyn_cast<Defined>(rel.sym))
       if (InputSection *isec = cast_or_null<InputSection>(d->section))
-        if (!isec || !isec->getFile<ELFT>() || isec->getFile<ELFT>()->splitStack)
+        if (!isec || !isec->getFile<ELFT>() ||
+            isec->getFile<ELFT>()->splitStack)
           continue;
 
     if (enclosingPrologueAttempted(rel.offset, prologues))
diff '--color=auto' -r -u llvm/lld/ELF/Relocations.cpp build/llvm-src/lld/ELF/Relocations.cpp
--- llvm/lld/ELF/Relocations.cpp	2023-12-29 21:47:41.712665574 +0100
+++ build/llvm-src/lld/ELF/Relocations.cpp	2024-01-02 03:15:13.629395130 +0100
@@ -56,6 +56,7 @@
 #include "llvm/BinaryFormat/ELF.h"
 #include "llvm/Demangle/Demangle.h"
 #include "llvm/Support/Endian.h"
+#include "llvm/Support/thread.h"
 #include <algorithm>
 
 using namespace llvm;
@@ -504,8 +505,7 @@
 }
 
 // Custom error message if Sym is defined in a discarded section.
-template <class ELFT>
-static std::string maybeReportDiscarded(Undefined &sym) {
+template <class ELFT> static std::string maybeReportDiscarded(Undefined &sym) {
   auto *file = dyn_cast_or_null<ObjFile<ELFT>>(sym.file);
   if (!file || !sym.discardedSecIdx)
     return "";
@@ -558,8 +558,8 @@
 };
 
 std::vector<UndefinedDiag> undefs;
-std::mutex relocMutex;
-}
+llvm::mutex relocMutex;
+} // namespace
 
 // Check whether the definition name def is a mangled function name that matches
 // the reference name ref.
@@ -804,7 +804,7 @@
 // Returns true if the undefined symbol will produce an error message.
 static bool maybeReportUndefined(Undefined &sym, InputSectionBase &sec,
                                  uint64_t offset) {
-  std::lock_guard<std::mutex> lock(relocMutex);
+  llvm::lock_guard<llvm::mutex> lock(relocMutex);
   // If versioned, issue an error (even if the symbol is weak) because we don't
   // know the defining filename which is required to construct a Verneed entry.
   if (sym.hasVersionSuffix) {
@@ -860,7 +860,7 @@
   Partition &part = isec.getPartition();
 
   if (sym.isTagged()) {
-    std::lock_guard<std::mutex> lock(relocMutex);
+    llvm::lock_guard<llvm::mutex> lock(relocMutex);
     part.relaDyn->addRelativeReloc(target->relativeRel, isec, offsetInSec, sym,
                                    addend, type, expr);
     // With MTE globals, we always want to derive the address tag by `ldg`-ing
@@ -1016,7 +1016,7 @@
   // We set the final symbols values for linker script defined symbols later.
   // They always can be computed as a link time constant.
   if (sym.scriptDefined)
-      return true;
+    return true;
 
   error("relocation " + toString(type) + " cannot refer to absolute symbol: " +
         toString(sym) + getLocation(*sec, sym, relOff));
@@ -1067,7 +1067,7 @@
   // We were asked not to generate PLT entries for ifuncs. Instead, pass the
   // direct relocation on through.
   if (LLVM_UNLIKELY(isIfunc) && config->zIfuncNoplt) {
-    std::lock_guard<std::mutex> lock(relocMutex);
+    llvm::lock_guard<llvm::mutex> lock(relocMutex);
     sym.exportDynamic = true;
     mainPart->relaDyn->addSymbolReloc(type, *sec, offset, sym, addend, type);
     return;
@@ -1132,7 +1132,7 @@
     } else if (rel != 0) {
       if (config->emachine == EM_MIPS && rel == target->symbolicRel)
         rel = target->relativeRel;
-      std::lock_guard<std::mutex> lock(relocMutex);
+      llvm::lock_guard<llvm::mutex> lock(relocMutex);
       sec->getPartition().relaDyn->addSymbolReloc(rel, *sec, offset, sym,
                                                   addend, type);
 
@@ -1282,11 +1282,10 @@
   // relaxation.
   // For PPC64, if the file has missing R_PPC64_TLSGD/R_PPC64_TLSLD, disable
   // relaxation as well.
-  bool toExecRelax = !config->shared && config->emachine != EM_ARM &&
-                     config->emachine != EM_HEXAGON &&
-                     config->emachine != EM_LOONGARCH &&
-                     config->emachine != EM_RISCV &&
-                     !c.file->ppc64DisableTLSRelax;
+  bool toExecRelax =
+      !config->shared && config->emachine != EM_ARM &&
+      config->emachine != EM_HEXAGON && config->emachine != EM_LOONGARCH &&
+      config->emachine != EM_RISCV && !c.file->ppc64DisableTLSRelax;
 
   // If we are producing an executable and the symbol is non-preemptable, it
   // must be defined and the code sequence can be relaxed to use Local-Exec.
diff '--color=auto' -r -u llvm/lld/include/lld/Common/ErrorHandler.h build/llvm-src/lld/include/lld/Common/ErrorHandler.h
--- llvm/lld/include/lld/Common/ErrorHandler.h	2023-12-29 16:36:22.539510827 +0100
+++ build/llvm-src/lld/include/lld/Common/ErrorHandler.h	2024-01-02 03:15:13.629395130 +0100
@@ -73,12 +73,12 @@
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/Error.h"
 #include "llvm/Support/FileOutputBuffer.h"
-#include <mutex>
+#include "llvm/Support/thread.h"
 
 namespace llvm {
 class DiagnosticInfo;
 class raw_ostream;
-}
+} // namespace llvm
 
 namespace lld {
 
@@ -136,7 +136,7 @@
   // be indirectly called from multiple threads, we protect them using a mutex.
   // In the future, we plan on supporting several concurrent linker contexts,
   // which explains why the mutex is not a global but part of this context.
-  std::mutex mu;
+  llvm::mutex mu;
   llvm::raw_ostream *stdoutOS{};
   llvm::raw_ostream *stderrOS{};
 };
diff '--color=auto' -r -u llvm/lld/include/lld/Common/Memory.h build/llvm-src/lld/include/lld/Common/Memory.h
--- llvm/lld/include/lld/Common/Memory.h	2023-12-29 16:36:22.539510827 +0100
+++ build/llvm-src/lld/include/lld/Common/Memory.h	2024-01-02 04:11:00.425366127 +0100
@@ -57,7 +57,7 @@
 
 // Creates new instances of T off a (almost) contiguous arena/object pool. The
 // instances are destroyed whenever lldMain() goes out of scope.
-template <typename T, typename... U> T *make(U &&... args) {
+template <typename T, typename... U> T *make(U &&...args) {
   return new (getSpecificAllocSingleton<T>().Allocate())
       T(std::forward<U>(args)...);
 }
@@ -65,7 +65,11 @@
 template <typename T>
 inline llvm::SpecificBumpPtrAllocator<T> &
 getSpecificAllocSingletonThreadLocal() {
+#if LLVM_ENABLE_THREADS
   thread_local SpecificAlloc<T> instance;
+#else
+  static SpecificAlloc<T> instance;
+#endif
   return instance.alloc;
 }
 
Only in build/llvm-src/lld/include/lld/Common: .Memory.h.swp
diff '--color=auto' -r -u llvm/lld/MachO/Writer.cpp build/llvm-src/lld/MachO/Writer.cpp
--- llvm/lld/MachO/Writer.cpp	2023-12-29 16:36:22.537510716 +0100
+++ build/llvm-src/lld/MachO/Writer.cpp	2024-01-02 03:15:13.629395130 +0100
@@ -30,6 +30,7 @@
 #include "llvm/Support/Path.h"
 #include "llvm/Support/ThreadPool.h"
 #include "llvm/Support/TimeProfiler.h"
+#include "llvm/Support/thread.h"
 #include "llvm/Support/xxhash.h"
 
 #include <algorithm>
@@ -1104,13 +1105,13 @@
       symtabSection,     indirectSymtabSection,
       dataInCodeSection, functionStartsSection,
   };
-  SmallVector<std::shared_future<void>> threadFutures;
+  SmallVector<llvm::shared_future<void>> threadFutures;
   threadFutures.reserve(linkEditSections.size());
   for (LinkEditSection *osec : linkEditSections)
     if (osec)
       threadFutures.emplace_back(threadPool.async(
           [](LinkEditSection *osec) { osec->finalizeContents(); }, osec));
-  for (std::shared_future<void> &future : threadFutures)
+  for (llvm::shared_future<void> &future : threadFutures)
     future.wait();
 
   // Now that __LINKEDIT is filled out, do a proper calculation of its
@@ -1185,12 +1186,12 @@
   std::vector<ArrayRef<uint8_t>> chunks = split(data, 1024 * 1024);
   // Leave one slot for filename
   std::vector<uint64_t> hashes(chunks.size() + 1);
-  SmallVector<std::shared_future<void>> threadFutures;
+  SmallVector<llvm::shared_future<void>> threadFutures;
   threadFutures.reserve(chunks.size());
   for (size_t i = 0; i < chunks.size(); ++i)
     threadFutures.emplace_back(threadPool.async(
         [&](size_t j) { hashes[j] = xxh3_64bits(chunks[j]); }, i));
-  for (std::shared_future<void> &future : threadFutures)
+  for (llvm::shared_future<void> &future : threadFutures)
     future.wait();
   // Append the output filename so that identical binaries with different names
   // don't get the same UUID.
diff '--color=auto' -r -u llvm/llvm/cmake/modules/HandleLLVMOptions.cmake build/llvm-src/llvm/cmake/modules/HandleLLVMOptions.cmake
--- llvm/llvm/cmake/modules/HandleLLVMOptions.cmake	2023-12-29 21:47:41.761668277 +0100
+++ build/llvm-src/llvm/cmake/modules/HandleLLVMOptions.cmake	2024-01-02 03:15:13.629395130 +0100
@@ -186,6 +186,10 @@
   else()
     set(LLVM_HAVE_LINK_VERSION_SCRIPT 1)
   endif()
+elseif(WASI)
+  set(LLVM_ON_WIN32 0)
+  set(LLVM_ON_UNIX 1)
+  set(LLVM_HAVE_LINK_VERSION_SCRIPT 0)
 elseif(CMAKE_SYSTEM_NAME STREQUAL "Generic")
   set(LLVM_ON_WIN32 0)
   set(LLVM_ON_UNIX 0)
diff '--color=auto' -r -u llvm/llvm/include/llvm/ADT/bit.h build/llvm-src/llvm/include/llvm/ADT/bit.h
--- llvm/llvm/include/llvm/ADT/bit.h	2023-12-29 21:47:41.774668994 +0100
+++ build/llvm-src/llvm/include/llvm/ADT/bit.h	2024-01-02 03:15:13.629395130 +0100
@@ -24,12 +24,12 @@
 #endif
 
 #if defined(_MSC_VER) && !defined(_DEBUG)
-#include <cstdlib>  // for _byteswap_{ushort,ulong,uint64}
+#include <cstdlib> // for _byteswap_{ushort,ulong,uint64}
 #endif
 
 #if defined(__linux__) || defined(__GNU__) || defined(__HAIKU__) ||            \
     defined(__Fuchsia__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__) ||  \
-    defined(__OpenBSD__) || defined(__DragonFly__)
+    defined(__OpenBSD__) || defined(__DragonFly__) || defined(__wasi__)
 #include <endian.h>
 #elif defined(_AIX)
 #include <sys/machine.h>
diff '--color=auto' -r -u llvm/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h build/llvm-src/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h
--- llvm/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h	2023-12-29 16:36:23.143544071 +0100
+++ build/llvm-src/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h	2024-01-02 03:15:13.629395130 +0100
@@ -11,8 +11,6 @@
 
 #include <functional>
 #include <memory>
-#include <mutex>
-#include <thread>
 
 #include "llvm/ADT/AddressRanges.h"
 #include "llvm/ADT/ArrayRef.h"
@@ -23,6 +21,7 @@
 #include "llvm/Support/Endian.h"
 #include "llvm/Support/Error.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/thread.h"
 
 namespace llvm {
 
@@ -132,7 +131,7 @@
 /// of FunctionInfo objects, see "llvm/DebugInfo/GSYM/FunctionInfo.h".
 class GsymCreator {
   // Private member variables require Mutex protections
-  mutable std::mutex Mutex;
+  mutable llvm::mutex Mutex;
   std::vector<FunctionInfo> Funcs;
   StringTableBuilder StrTab;
   StringSet<> StringStorage;
@@ -147,7 +146,6 @@
   bool Finalized = false;
   bool Quiet;
 
-
   /// Get the first function start address.
   ///
   /// \returns The start address of the first FunctionInfo or std::nullopt if
@@ -286,9 +284,7 @@
   /// When we have a segment, we know that function infos will be added in
   /// ascending address range order without having to be finalized. We also
   /// don't need to sort and unique entries during the finalize function call.
-  void setIsSegment() {
-    IsSegment = true;
-  }
+  void setIsSegment() { IsSegment = true; }
 
 public:
   GsymCreator(bool Quiet = false);
@@ -373,8 +369,7 @@
   ///
   /// \param  Callback A callback function that will get called with each
   ///         FunctionInfo. If the callback returns false, stop iterating.
-  void forEachFunctionInfo(
-      std::function<bool(FunctionInfo &)> const &Callback);
+  void forEachFunctionInfo(std::function<bool(FunctionInfo &)> const &Callback);
 
   /// Thread safe const iteration over all function infos.
   ///
@@ -429,14 +424,11 @@
   ///
   /// \param  Addr The address to use as the base address of the GSYM file
   ///              when it is saved to disk.
-  void setBaseAddress(uint64_t Addr) {
-    BaseAddress = Addr;
-  }
+  void setBaseAddress(uint64_t Addr) { BaseAddress = Addr; }
 
   /// Whether the transformation should be quiet, i.e. not output warnings.
   bool isQuiet() const { return Quiet; }
 
-
   /// Create a segmented GSYM creator starting with function info index
   /// \a FuncIdx.
   ///
diff '--color=auto' -r -u llvm/llvm/include/llvm/Debuginfod/Debuginfod.h build/llvm-src/llvm/include/llvm/Debuginfod/Debuginfod.h
--- llvm/llvm/include/llvm/Debuginfod/Debuginfod.h	2023-12-29 21:47:41.786669656 +0100
+++ build/llvm-src/llvm/include/llvm/Debuginfod/Debuginfod.h	2024-01-02 03:15:13.629395130 +0100
@@ -92,8 +92,8 @@
 };
 
 class DebuginfodLog {
-  std::mutex QueueMutex;
-  std::condition_variable QueueCondition;
+  llvm::mutex QueueMutex;
+  llvm::condition_variable QueueCondition;
   std::queue<DebuginfodLogEntry> LogEntryQueue;
 
 public:
diff '--color=auto' -r -u llvm/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h build/llvm-src/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h
--- llvm/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h	2023-12-29 16:36:23.150544456 +0100
+++ build/llvm-src/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h	2024-01-02 03:15:13.629395130 +0100
@@ -24,10 +24,9 @@
 #include "llvm/Support/MSVCErrorWorkarounds.h"
 #include "llvm/Support/Memory.h"
 #include "llvm/Support/RecyclingAllocator.h"
+#include "llvm/Support/thread.h"
 
 #include <cstdint>
-#include <future>
-#include <mutex>
 
 namespace llvm {
 namespace jitlink {
@@ -42,7 +41,6 @@
 /// and their implemetations should include any necessary synchronization.
 class JITLinkMemoryManager {
 public:
-
   /// Represents a finalized allocation.
   ///
   /// Finalized allocations must be passed to the
diff '--color=auto' -r -u llvm/llvm/include/llvm/IR/ValueMap.h build/llvm-src/llvm/include/llvm/IR/ValueMap.h
--- llvm/llvm/include/llvm/IR/ValueMap.h	2023-12-29 16:36:23.171545612 +0100
+++ build/llvm-src/llvm/include/llvm/IR/ValueMap.h	2024-01-02 03:15:13.630395186 +0100
@@ -42,18 +42,15 @@
 
 namespace llvm {
 
-template<typename KeyT, typename ValueT, typename Config>
+template <typename KeyT, typename ValueT, typename Config>
 class ValueMapCallbackVH;
-template<typename DenseMapT, typename KeyT>
-class ValueMapIterator;
-template<typename DenseMapT, typename KeyT>
-class ValueMapConstIterator;
+template <typename DenseMapT, typename KeyT> class ValueMapIterator;
+template <typename DenseMapT, typename KeyT> class ValueMapConstIterator;
 
 /// This class defines the default behavior for configurable aspects of
 /// ValueMap<>.  User Configs should inherit from this class to be as compatible
 /// as possible with future versions of ValueMap.
-template<typename KeyT, typename MutexT = sys::Mutex>
-struct ValueMapConfig {
+template <typename KeyT, typename MutexT = sys::Mutex> struct ValueMapConfig {
   using mutex_type = MutexT;
 
   /// If FollowRAUW is true, the ValueMap will update mappings on RAUW. If it's
@@ -66,21 +63,24 @@
   // override all the defaults.
   struct ExtraData {};
 
-  template<typename ExtraDataT>
+  template <typename ExtraDataT>
   static void onRAUW(const ExtraDataT & /*Data*/, KeyT /*Old*/, KeyT /*New*/) {}
-  template<typename ExtraDataT>
-  static void onDelete(const ExtraDataT &/*Data*/, KeyT /*Old*/) {}
+  template <typename ExtraDataT>
+  static void onDelete(const ExtraDataT & /*Data*/, KeyT /*Old*/) {}
 
   /// Returns a mutex that should be acquired around any changes to the map.
   /// This is only acquired from the CallbackVH (and held around calls to onRAUW
   /// and onDelete) and not inside other ValueMap methods.  NULL means that no
   /// mutex is necessary.
-  template<typename ExtraDataT>
-  static mutex_type *getMutex(const ExtraDataT &/*Data*/) { return nullptr; }
+  template <typename ExtraDataT>
+  static mutex_type *getMutex(const ExtraDataT & /*Data*/) {
+    return nullptr;
+  }
 };
 
 /// See the file comment.
-template<typename KeyT, typename ValueT, typename Config =ValueMapConfig<KeyT>>
+template <typename KeyT, typename ValueT,
+          typename Config = ValueMapConfig<KeyT>>
 class ValueMap {
   friend class ValueMapCallbackVH<KeyT, ValueT, Config>;
 
@@ -152,9 +152,7 @@
     return Map.find_as(Val) == Map.end() ? 0 : 1;
   }
 
-  iterator find(const KeyT &Val) {
-    return iterator(Map.find_as(Val));
-  }
+  iterator find(const KeyT &Val) { return iterator(Map.find_as(Val)); }
   const_iterator find(const KeyT &Val) const {
     return const_iterator(Map.find_as(Val));
   }
@@ -181,8 +179,7 @@
   }
 
   /// insert - Range insertion of pairs.
-  template<typename InputIt>
-  void insert(InputIt I, InputIt E) {
+  template <typename InputIt> void insert(InputIt I, InputIt E) {
     for (; I != E; ++I)
       insert(*I);
   }
@@ -195,17 +192,13 @@
     Map.erase(I);
     return true;
   }
-  void erase(iterator I) {
-    return Map.erase(I.base());
-  }
+  void erase(iterator I) { return Map.erase(I.base()); }
 
-  value_type& FindAndConstruct(const KeyT &Key) {
+  value_type &FindAndConstruct(const KeyT &Key) {
     return Map.FindAndConstruct(Wrap(Key));
   }
 
-  ValueT &operator[](const KeyT &Key) {
-    return Map[Wrap(Key)];
-  }
+  ValueT &operator[](const KeyT &Key) { return Map[Wrap(Key)]; }
 
   /// isPointerIntoBucketsArray - Return true if the specified pointer points
   /// somewhere into the ValueMap's array of buckets (i.e. either to a key or
@@ -230,7 +223,7 @@
     // the const_cast incorrect) is if it gets inserted into the map.  But then
     // this function must have been called from a non-const method, making the
     // const_cast ok.
-    return ValueMapCVH(key, const_cast<ValueMap*>(this));
+    return ValueMapCVH(key, const_cast<ValueMap *>(this));
   }
 };
 
@@ -247,7 +240,7 @@
   ValueMapT *Map;
 
   ValueMapCallbackVH(KeyT Key, ValueMapT *Map)
-      : CallbackVH(const_cast<Value*>(static_cast<const Value*>(Key))),
+      : CallbackVH(const_cast<Value *>(static_cast<const Value *>(Key))),
         Map(Map) {}
 
   // Private constructor used to create empty/tombstone DenseMap keys.
@@ -260,11 +253,11 @@
     // Make a copy that won't get changed even when *this is destroyed.
     ValueMapCallbackVH Copy(*this);
     typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);
-    std::unique_lock<typename Config::mutex_type> Guard;
+    llvm::unique_lock<typename Config::mutex_type> Guard;
     if (M)
-      Guard = std::unique_lock<typename Config::mutex_type>(*M);
-    Config::onDelete(Copy.Map->Data, Copy.Unwrap());  // May destroy *this.
-    Copy.Map->Map.erase(Copy);  // Definitely destroys *this.
+      Guard = llvm::unique_lock<typename Config::mutex_type>(*M);
+    Config::onDelete(Copy.Map->Data, Copy.Unwrap()); // May destroy *this.
+    Copy.Map->Map.erase(Copy); // Definitely destroys *this.
   }
 
   void allUsesReplacedWith(Value *new_key) override {
@@ -273,9 +266,9 @@
     // Make a copy that won't get changed even when *this is destroyed.
     ValueMapCallbackVH Copy(*this);
     typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);
-    std::unique_lock<typename Config::mutex_type> Guard;
+    llvm::unique_lock<typename Config::mutex_type> Guard;
     if (M)
-      Guard = std::unique_lock<typename Config::mutex_type>(*M);
+      Guard = llvm::unique_lock<typename Config::mutex_type>(*M);
 
     KeyT typed_new_key = cast<KeySansPointerT>(new_key);
     // Can destroy *this:
@@ -286,14 +279,14 @@
       // removed the old mapping.
       if (I != Copy.Map->Map.end()) {
         ValueT Target(std::move(I->second));
-        Copy.Map->Map.erase(I);  // Definitely destroys *this.
+        Copy.Map->Map.erase(I); // Definitely destroys *this.
         Copy.Map->insert(std::make_pair(typed_new_key, std::move(Target)));
       }
     }
   }
 };
 
-template<typename KeyT, typename ValueT, typename Config>
+template <typename KeyT, typename ValueT, typename Config>
 struct DenseMapInfo<ValueMapCallbackVH<KeyT, ValueT, Config>> {
   using VH = ValueMapCallbackVH<KeyT, ValueT, Config>;
 
@@ -313,9 +306,7 @@
     return DenseMapInfo<KeyT>::getHashValue(Val);
   }
 
-  static bool isEqual(const VH &LHS, const VH &RHS) {
-    return LHS == RHS;
-  }
+  static bool isEqual(const VH &LHS, const VH &RHS) { return LHS == RHS; }
 
   static bool isEqual(const KeyT &LHS, const VH &RHS) {
     return LHS == RHS.getValPtr();
@@ -342,7 +333,7 @@
 
   struct ValueTypeProxy {
     const KeyT first;
-    ValueT& second;
+    ValueT &second;
 
     ValueTypeProxy *operator->() { return this; }
 
@@ -356,23 +347,19 @@
     return Result;
   }
 
-  ValueTypeProxy operator->() const {
-    return operator*();
-  }
+  ValueTypeProxy operator->() const { return operator*(); }
 
-  bool operator==(const ValueMapIterator &RHS) const {
-    return I == RHS.I;
-  }
-  bool operator!=(const ValueMapIterator &RHS) const {
-    return I != RHS.I;
-  }
+  bool operator==(const ValueMapIterator &RHS) const { return I == RHS.I; }
+  bool operator!=(const ValueMapIterator &RHS) const { return I != RHS.I; }
 
-  inline ValueMapIterator& operator++() {  // Preincrement
+  inline ValueMapIterator &operator++() { // Preincrement
     ++I;
     return *this;
   }
-  ValueMapIterator operator++(int) {  // Postincrement
-    ValueMapIterator tmp = *this; ++*this; return tmp;
+  ValueMapIterator operator++(int) { // Postincrement
+    ValueMapIterator tmp = *this;
+    ++*this;
+    return tmp;
   }
 };
 
@@ -392,13 +379,13 @@
   ValueMapConstIterator() : I() {}
   ValueMapConstIterator(BaseT I) : I(I) {}
   ValueMapConstIterator(ValueMapIterator<DenseMapT, KeyT> Other)
-    : I(Other.base()) {}
+      : I(Other.base()) {}
 
   BaseT base() const { return I; }
 
   struct ValueTypeProxy {
     const KeyT first;
-    const ValueT& second;
+    const ValueT &second;
     ValueTypeProxy *operator->() { return this; }
     operator std::pair<KeyT, ValueT>() const {
       return std::make_pair(first, second);
@@ -410,23 +397,19 @@
     return Result;
   }
 
-  ValueTypeProxy operator->() const {
-    return operator*();
-  }
+  ValueTypeProxy operator->() const { return operator*(); }
 
-  bool operator==(const ValueMapConstIterator &RHS) const {
-    return I == RHS.I;
-  }
-  bool operator!=(const ValueMapConstIterator &RHS) const {
-    return I != RHS.I;
-  }
+  bool operator==(const ValueMapConstIterator &RHS) const { return I == RHS.I; }
+  bool operator!=(const ValueMapConstIterator &RHS) const { return I != RHS.I; }
 
-  inline ValueMapConstIterator& operator++() {  // Preincrement
+  inline ValueMapConstIterator &operator++() { // Preincrement
     ++I;
     return *this;
   }
-  ValueMapConstIterator operator++(int) {  // Postincrement
-    ValueMapConstIterator tmp = *this; ++*this; return tmp;
+  ValueMapConstIterator operator++(int) { // Postincrement
+    ValueMapConstIterator tmp = *this;
+    ++*this;
+    return tmp;
   }
 };
 
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/BalancedPartitioning.h build/llvm-src/llvm/include/llvm/Support/BalancedPartitioning.h
--- llvm/llvm/include/llvm/Support/BalancedPartitioning.h	2023-12-29 16:36:23.186546437 +0100
+++ build/llvm-src/llvm/include/llvm/Support/BalancedPartitioning.h	2024-01-02 03:15:13.630395186 +0100
@@ -41,10 +41,9 @@
 
 #include "raw_ostream.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/thread.h"
 
 #include <atomic>
-#include <condition_variable>
-#include <mutex>
 #include <random>
 #include <vector>
 
@@ -116,8 +115,8 @@
   /// threads.
   struct BPThreadPool {
     ThreadPool &TheThreadPool;
-    std::mutex mtx;
-    std::condition_variable cv;
+    llvm::mutex mtx;
+    llvm::condition_variable cv;
     /// The number of threads that could spawn more threads
     std::atomic<int> NumActiveThreads = 0;
     /// Only true when all threads are down spawning new threads
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/FileCollector.h build/llvm-src/llvm/include/llvm/Support/FileCollector.h
--- llvm/llvm/include/llvm/Support/FileCollector.h	2023-12-29 16:36:23.189546603 +0100
+++ build/llvm-src/llvm/include/llvm/Support/FileCollector.h	2024-01-02 03:15:13.630395186 +0100
@@ -12,7 +12,7 @@
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringSet.h"
 #include "llvm/Support/VirtualFileSystem.h"
-#include <mutex>
+#include "llvm/Support/thread.h"
 #include <string>
 
 namespace llvm {
@@ -42,7 +42,7 @@
                    std::error_code &EC) = 0;
 
   /// Synchronizes access to internal data structures.
-  std::mutex Mutex;
+  llvm::mutex Mutex;
 
   /// Tracks already seen files so they can be skipped.
   StringSet<> Seen;
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/Mutex.h build/llvm-src/llvm/include/llvm/Support/Mutex.h
--- llvm/llvm/include/llvm/Support/Mutex.h	2023-12-29 16:36:23.191546713 +0100
+++ build/llvm-src/llvm/include/llvm/Support/Mutex.h	2024-01-02 03:15:13.630395186 +0100
@@ -1,4 +1,5 @@
-//===- llvm/Support/Mutex.h - Mutex Operating System Concept -----*- C++ -*-===//
+//===- llvm/Support/Mutex.h - Mutex Operating System Concept -----*- C++
+//-*-===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
@@ -14,62 +15,59 @@
 #define LLVM_SUPPORT_MUTEX_H
 
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 #include <cassert>
-#include <mutex>
 
-namespace llvm
-{
-  namespace sys
-  {
-    /// SmartMutex - A mutex with a compile time constant parameter that
-    /// indicates whether this mutex should become a no-op when we're not
-    /// running in multithreaded mode.
-    template<bool mt_only>
-    class SmartMutex {
-      std::recursive_mutex impl;
-      unsigned acquired = 0;
-
-    public:
-      bool lock() {
-        if (!mt_only || llvm_is_multithreaded()) {
-          impl.lock();
-          return true;
-        }
-        // Single-threaded debugging code.  This would be racy in
-        // multithreaded mode, but provides not basic checks in single
-        // threaded mode.
-        ++acquired;
-        return true;
-      }
-
-      bool unlock() {
-        if (!mt_only || llvm_is_multithreaded()) {
-          impl.unlock();
-          return true;
-        }
-        // Single-threaded debugging code.  This would be racy in
-        // multithreaded mode, but provides not basic checks in single
-        // threaded mode.
-        assert(acquired && "Lock not acquired before release!");
-        --acquired;
-        return true;
-      }
-
-      bool try_lock() {
-        if (!mt_only || llvm_is_multithreaded())
-          return impl.try_lock();
-        return true;
-      }
-    };
-
-    /// Mutex - A standard, always enforced mutex.
-    typedef SmartMutex<false> Mutex;
+namespace llvm {
+namespace sys {
+/// SmartMutex - A mutex with a compile time constant parameter that
+/// indicates whether this mutex should become a no-op when we're not
+/// running in multithreaded mode.
+template <bool mt_only> class SmartMutex {
+  llvm::recursive_mutex impl;
+  unsigned acquired = 0;
+
+public:
+  bool lock() {
+    if (!mt_only || llvm_is_multithreaded()) {
+      impl.lock();
+      return true;
+    }
+    // Single-threaded debugging code.  This would be racy in
+    // multithreaded mode, but provides not basic checks in single
+    // threaded mode.
+    ++acquired;
+    return true;
+  }
 
-    template <bool mt_only>
-    using SmartScopedLock = std::lock_guard<SmartMutex<mt_only>>;
+  bool unlock() {
+    if (!mt_only || llvm_is_multithreaded()) {
+      impl.unlock();
+      return true;
+    }
+    // Single-threaded debugging code.  This would be racy in
+    // multithreaded mode, but provides not basic checks in single
+    // threaded mode.
+    assert(acquired && "Lock not acquired before release!");
+    --acquired;
+    return true;
+  }
 
-    typedef SmartScopedLock<false> ScopedLock;
+  bool try_lock() {
+    if (!mt_only || llvm_is_multithreaded())
+      return impl.try_lock();
+    return true;
   }
-}
+};
+
+/// Mutex - A standard, always enforced mutex.
+typedef SmartMutex<false> Mutex;
+
+template <bool mt_only>
+using SmartScopedLock = llvm::lock_guard<SmartMutex<mt_only>>;
+
+typedef SmartScopedLock<false> ScopedLock;
+} // namespace sys
+} // namespace llvm
 
 #endif
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/Parallel.h build/llvm-src/llvm/include/llvm/Support/Parallel.h
--- llvm/llvm/include/llvm/Support/Parallel.h	2023-12-29 16:36:23.192546768 +0100
+++ build/llvm-src/llvm/include/llvm/Support/Parallel.h	2024-01-02 03:15:13.630395186 +0100
@@ -14,11 +14,10 @@
 #include "llvm/Support/Error.h"
 #include "llvm/Support/MathExtras.h"
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 
 #include <algorithm>
-#include <condition_variable>
 #include <functional>
-#include <mutex>
 
 namespace llvm {
 
@@ -58,8 +57,8 @@
 namespace detail {
 class Latch {
   uint32_t Count;
-  mutable std::mutex Mutex;
-  mutable std::condition_variable Cond;
+  mutable llvm::mutex Mutex;
+  mutable llvm::condition_variable Cond;
 
 public:
   explicit Latch(uint32_t Count = 0) : Count(Count) {}
@@ -69,18 +68,18 @@
   }
 
   void inc() {
-    std::lock_guard<std::mutex> lock(Mutex);
+    llvm::lock_guard<llvm::mutex> lock(Mutex);
     ++Count;
   }
 
   void dec() {
-    std::lock_guard<std::mutex> lock(Mutex);
+    llvm::lock_guard<llvm::mutex> lock(Mutex);
     if (--Count == 0)
       Cond.notify_all();
   }
 
   void sync() const {
-    std::unique_lock<std::mutex> lock(Mutex);
+    llvm::unique_lock<llvm::mutex> lock(Mutex);
     Cond.wait(lock, [&] { return Count == 0; });
   }
 };
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/RWMutex.h build/llvm-src/llvm/include/llvm/Support/RWMutex.h
--- llvm/llvm/include/llvm/Support/RWMutex.h	2023-12-29 16:36:23.192546768 +0100
+++ build/llvm-src/llvm/include/llvm/Support/RWMutex.h	2024-01-02 03:15:13.630395186 +0100
@@ -15,9 +15,8 @@
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 #include <cassert>
-#include <mutex>
-#include <shared_mutex>
 
 #if defined(__APPLE__)
 #define LLVM_USE_RW_MUTEX_IMPL
@@ -90,7 +89,7 @@
 /// running in multithreaded mode.
 template <bool mt_only> class SmartRWMutex {
 #if !defined(LLVM_USE_RW_MUTEX_IMPL)
-  std::shared_mutex impl;
+  llvm::shared_mutex impl;
 #else
   RWMutexImpl impl;
 #endif
@@ -155,7 +154,7 @@
 /// ScopedReader - RAII acquisition of a reader lock
 #if !defined(LLVM_USE_RW_MUTEX_IMPL)
 template <bool mt_only>
-using SmartScopedReader = const std::shared_lock<SmartRWMutex<mt_only>>;
+using SmartScopedReader = const llvm::shared_lock<SmartRWMutex<mt_only>>;
 #else
 template <bool mt_only> struct SmartScopedReader {
   SmartRWMutex<mt_only> &mutex;
@@ -172,7 +171,7 @@
 /// ScopedWriter - RAII acquisition of a writer lock
 #if !defined(LLVM_USE_RW_MUTEX_IMPL)
 template <bool mt_only>
-using SmartScopedWriter = std::lock_guard<SmartRWMutex<mt_only>>;
+using SmartScopedWriter = llvm::lock_guard<SmartRWMutex<mt_only>>;
 #else
 template <bool mt_only> struct SmartScopedWriter {
   SmartRWMutex<mt_only> &mutex;
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/thread.h build/llvm-src/llvm/include/llvm/Support/thread.h
--- llvm/llvm/include/llvm/Support/thread.h	2023-12-29 16:36:23.195546933 +0100
+++ build/llvm-src/llvm/include/llvm/Support/thread.h	2024-01-02 03:56:24.245012614 +0100
@@ -27,10 +27,47 @@
 
 #if LLVM_ENABLE_THREADS
 
+#include <condition_variable>
+#include <future>
+#include <mutex>
+#include <shared_mutex>
 #include <thread>
+#include <type_traits>
 
 namespace llvm {
 
+namespace this_thread {
+using namespace std::this_thread;
+}
+
+using mutex = std::mutex;
+using recursive_mutex = std::recursive_mutex;
+using shared_mutex = std::shared_mutex;
+template <typename T> using shared_lock = std::shared_lock<T>;
+template <typename T> using lock_guard = std::lock_guard<T>;
+template <typename T> using unique_lock = std::unique_lock<T>;
+template <typename... T> using scoped_lock = std::scoped_lock<T...>;
+using condition_variable = std::condition_variable;
+using launch = std::launch;
+template <typename T> using shared_future = std::shared_future<T>;
+template <typename T> using future = std::future<T>;
+template <typename T> using promise = std::promise<T>;
+
+template <class Function, class... Args>
+[[nodiscard]] std::future<
+    std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
+async(Function &&f, Args &&...args) {
+  return std::async(std::forward<Function>(f), std::forward<Args>(args)...);
+}
+
+template <class Function, class... Args>
+[[nodiscard]] std::future<
+    std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
+async(std::launch policy, Function &&f, Args &&...args) {
+  return std::async(policy, std::forward<Function>(f),
+                    std::forward<Args>(args)...);
+}
+
 #if LLVM_ON_UNIX || _WIN32
 
 /// LLVM thread following std::thread interface with added constructor to
@@ -202,8 +239,8 @@
 };
 
 namespace this_thread {
-  inline thread::id get_id() { return std::this_thread::get_id(); }
-}
+inline thread::id get_id() { return std::this_thread::get_id(); }
+} // namespace this_thread
 
 #endif // LLVM_ON_UNIX || _WIN32
 
@@ -211,6 +248,11 @@
 
 #else // !LLVM_ENABLE_THREADS
 
+#include <chrono>
+#include <functional>
+#include <memory>
+#include <tuple>
+#include <type_traits>
 #include <utility>
 
 namespace llvm {
@@ -237,6 +279,158 @@
   static unsigned hardware_concurrency() { return 1; };
 };
 
+enum class launch : unsigned { async = 1, deferred = 2 };
+
+inline launch operator|(launch a, launch b) {
+  return launch((unsigned)a | (unsigned)b);
+}
+
+struct mutex {
+  void lock() {}
+  void unlock() {}
+};
+struct recursive_mutex {
+  void lock() {}
+  void unlock() {}
+  bool try_lock() { return true; }
+};
+struct shared_mutex {
+  void lock_shared() {}
+  void unlock_shared() {}
+  void lock() {}
+  void unlock() {}
+};
+
+template <typename T> struct lock_guard {
+  lock_guard(T &) {}
+  void lock() {}
+  void unlock() {}
+};
+
+template <typename T> struct unique_lock {
+  unique_lock() {}
+  unique_lock(T &) {}
+  void lock() {}
+  void unlock() {}
+};
+
+template <typename T> struct shared_lock {
+  shared_lock() {}
+  shared_lock(T &) {}
+  void lock() {}
+  void unlock() {}
+  void lock_shared() {}
+  void unlock_shared() {}
+};
+
+template <typename... T> struct scoped_lock {
+  explicit scoped_lock(T &...) {}
+};
+
+struct condition_variable {
+  void notify_all() {}
+  void notify_one() {}
+  void wait(unique_lock<mutex> &) {
+    report_fatal_error("Cannot wait on tasks with no threads");
+  }
+  template <class Predicate>
+  void wait(unique_lock<mutex> &lock, Predicate stop_waiting) {
+    if (stop_waiting()) {
+      return;
+    }
+    wait(lock);
+  }
+};
+
+template <typename T> struct future_state {
+  std::optional<T> value;
+  std::function<T()> run;
+
+  T &get() {
+    if (!value.has_value()) {
+      value = run();
+    }
+    return *value;
+  }
+};
+
+template <> struct future_state<void> {
+  std::function<void()> run;
+  bool has_ran = false;
+
+  void get() {
+    if (!has_ran) {
+      run();
+      has_ran = true;
+    }
+  }
+};
+
+template <typename T> struct future;
+
+template <typename T> struct shared_future_get { using type = const T &; };
+template <> struct shared_future_get<void> { using type = void; };
+
+template <typename T> struct shared_future {
+  shared_future(future<T> &&f) {
+    state = std::move(f.state);
+    f.state = nullptr;
+  }
+
+  typename shared_future_get<T>::type get() const { return (*state).get(); }
+
+  void wait() const { get(); }
+
+  std::shared_ptr<future_state<T>> state;
+};
+
+template <typename T> struct future {
+  shared_future<T> share() { return shared_future<T>(std::move(*this)); }
+
+  T get() const { return std::move((*state).get()); }
+
+  std::shared_ptr<future_state<T>> state;
+};
+
+template <> struct future<void> {
+  shared_future<void> share() { return shared_future<void>(std::move(*this)); }
+
+  void get() const { return (*state).get(); }
+
+  std::shared_ptr<future_state<void>> state;
+};
+
+template <class Function, class... Args>
+[[nodiscard]] future<
+    std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
+async(launch policy, Function &&f, Args &&...args) {
+  if (!((unsigned)policy & (unsigned)launch::deferred)) {
+    report_fatal_error("Cannot asynchonously launch tasks with no threads");
+  }
+  using T = std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>;
+  std::shared_ptr<future_state<T>> state = std::make_shared<future_state<T>>();
+  auto all_args = std::make_tuple(std::forward<Args>(args)...);
+  state->run = [all_args = std::move(all_args), f = std::move(f)]() {
+    return std::apply(f, all_args);
+  };
+  return future<T>{state};
+}
+
+template <class Function, class... Args>
+[[nodiscard]] future<
+    std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
+async(Function &&f, Args &&...args) {
+  return async(launch::async | launch::deferred, std::forward<Function>(f),
+               std::forward<Args>(args)...);
+}
+
+namespace this_thread {
+template <class Rep, class Period>
+void sleep_for(const std::chrono::duration<Rep, Period> &) {
+  // noop
+}
+} // namespace this_thread
+
 } // namespace llvm
 
 #endif // LLVM_ENABLE_THREADS
diff '--color=auto' -r -u llvm/llvm/include/llvm/Support/ThreadPool.h build/llvm-src/llvm/include/llvm/Support/ThreadPool.h
--- llvm/llvm/include/llvm/Support/ThreadPool.h	2023-12-29 16:36:23.194546878 +0100
+++ build/llvm-src/llvm/include/llvm/Support/ThreadPool.h	2024-01-02 03:15:13.630395186 +0100
@@ -19,13 +19,9 @@
 #include "llvm/Support/Threading.h"
 #include "llvm/Support/thread.h"
 
-#include <future>
-
-#include <condition_variable>
 #include <deque>
 #include <functional>
 #include <memory>
-#include <mutex>
 #include <utility>
 
 namespace llvm {
@@ -80,14 +76,14 @@
   /// Asynchronous submission of a task to the pool. The returned future can be
   /// used to wait for the task to finish and is *non-blocking* on destruction.
   template <typename Func>
-  auto async(Func &&F) -> std::shared_future<decltype(F())> {
+  auto async(Func &&F) -> llvm::shared_future<decltype(F())> {
     return asyncImpl(std::function<decltype(F())()>(std::forward<Func>(F)),
                      nullptr);
   }
 
   template <typename Func>
   auto async(ThreadPoolTaskGroup &Group, Func &&F)
-      -> std::shared_future<decltype(F())> {
+      -> llvm::shared_future<decltype(F())> {
     return asyncImpl(std::function<decltype(F())()>(std::forward<Func>(F)),
                      &Group);
   }
@@ -113,11 +109,12 @@
   bool isWorkerThread() const;
 
 private:
+#if LLVM_ENABLE_THREADS
   /// Helpers to create a promise and a callable wrapper of \p Task that sets
   /// the result of the promise. Returns the callable and a future to access the
   /// result.
   template <typename ResTy>
-  static std::pair<std::function<void()>, std::future<ResTy>>
+  static std::pair<std::function<void()>, llvm::future<ResTy>>
   createTaskAndFuture(std::function<ResTy()> Task) {
     std::shared_ptr<std::promise<ResTy>> Promise =
         std::make_shared<std::promise<ResTy>>();
@@ -126,7 +123,7 @@
         [Promise = std::move(Promise), Task]() { Promise->set_value(Task()); },
         std::move(F)};
   }
-  static std::pair<std::function<void()>, std::future<void>>
+  static std::pair<std::function<void()>, llvm::future<void>>
   createTaskAndFuture(std::function<void()> Task) {
     std::shared_ptr<std::promise<void>> Promise =
         std::make_shared<std::promise<void>>();
@@ -137,6 +134,7 @@
             },
             std::move(F)};
   }
+#endif
 
   /// Returns true if all tasks in the given group have finished (nullptr means
   /// all tasks regardless of their group). QueueLock must be locked.
@@ -145,8 +143,8 @@
   /// Asynchronous submission of a task to the pool. The returned future can be
   /// used to wait for the task to finish and is *non-blocking* on destruction.
   template <typename ResTy>
-  std::shared_future<ResTy> asyncImpl(std::function<ResTy()> Task,
-                                      ThreadPoolTaskGroup *Group) {
+  llvm::shared_future<ResTy> asyncImpl(std::function<ResTy()> Task,
+                                       ThreadPoolTaskGroup *Group) {
 
 #if LLVM_ENABLE_THREADS
     /// Wrap the Task in a std::function<void()> that sets the result of the
@@ -156,7 +154,7 @@
     int requestedThreads;
     {
       // Lock the queue and push the new task
-      std::unique_lock<std::mutex> LockGuard(QueueLock);
+      std::unique_lock<llvm::mutex> LockGuard(QueueLock);
 
       // Don't allow enqueueing after disabling the pool
       assert(EnableFlag && "Queuing a thread during ThreadPool destruction");
@@ -169,8 +167,8 @@
 
 #else // LLVM_ENABLE_THREADS Disabled
 
-    // Get a Future with launch::deferred execution using std::async
-    auto Future = std::async(std::launch::deferred, std::move(Task)).share();
+    // Get a Future with launch::deferred execution using llvm::async
+    auto Future = llvm::async(llvm::launch::deferred, std::move(Task)).share();
     // Wrap the future so that both ThreadPool::wait() can operate and the
     // returned future can be sync'ed on.
     Tasks.emplace_back(std::make_pair([Future]() { Future.get(); }, Group));
@@ -195,11 +193,11 @@
   std::deque<std::pair<std::function<void()>, ThreadPoolTaskGroup *>> Tasks;
 
   /// Locking and signaling for accessing the Tasks queue.
-  std::mutex QueueLock;
-  std::condition_variable QueueCondition;
+  llvm::mutex QueueLock;
+  llvm::condition_variable QueueCondition;
 
   /// Signaling for job completion (all tasks or all tasks in a group).
-  std::condition_variable CompletionCondition;
+  llvm::condition_variable CompletionCondition;
 
   /// Keep track of the number of thread actually busy
   unsigned ActiveThreads = 0;
diff '--color=auto' -r -u llvm/llvm/lib/CMakeLists.txt build/llvm-src/llvm/lib/CMakeLists.txt
--- llvm/llvm/lib/CMakeLists.txt	2023-12-29 16:36:23.232548969 +0100
+++ build/llvm-src/llvm/lib/CMakeLists.txt	2024-01-02 03:15:13.630395186 +0100
@@ -31,7 +31,9 @@
 add_subdirectory(Debuginfod)
 add_subdirectory(DebugInfo)
 add_subdirectory(DWP)
+if (NOT WASI)
 add_subdirectory(ExecutionEngine)
+endif ()
 add_subdirectory(Target)
 add_subdirectory(AsmParser)
 add_subdirectory(LineEditor)
diff '--color=auto' -r -u llvm/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp build/llvm-src/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp
--- llvm/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp	2023-12-29 16:36:23.293552327 +0100
+++ build/llvm-src/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp	2024-01-02 03:15:13.631395241 +0100
@@ -47,11 +47,12 @@
 #include "llvm/Support/DataExtractor.h"
 #include "llvm/Support/Error.h"
 #include "llvm/Support/Format.h"
-#include "llvm/Support/LEB128.h"
 #include "llvm/Support/FormatVariadic.h"
+#include "llvm/Support/LEB128.h"
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/thread.h"
 #include <algorithm>
 #include <cstdint>
 #include <deque>
@@ -70,7 +71,6 @@
 using FileLineInfoKind = DILineInfoSpecifier::FileLineInfoKind;
 using FunctionNameKind = DILineInfoSpecifier::FunctionNameKind;
 
-
 void fixupIndexV4(DWARFContext &C, DWARFUnitIndex &Index) {
   using EntryType = DWARFUnitIndex::Entry::SectionContribution;
   using EntryMap = DenseMap<uint32_t, EntryType>;
@@ -203,7 +203,6 @@
   return *Cache;
 }
 
-
 std::unique_ptr<DWARFDebugMacro>
 DWARFContext::DWARFContextState::parseMacroOrMacinfo(MacroSecType SectionType) {
   auto Macro = std::make_unique<DWARFDebugMacro>();
@@ -282,9 +281,8 @@
   std::string DWPName;
 
 public:
-  ThreadUnsafeDWARFContextState(DWARFContext &DC, std::string &DWP) :
-      DWARFContext::DWARFContextState(DC),
-      DWPName(std::move(DWP)) {}
+  ThreadUnsafeDWARFContextState(DWARFContext &DC, std::string &DWP)
+      : DWARFContext::DWARFContextState(DC), DWPName(std::move(DWP)) {}
 
   DWARFUnitVector &getNormalUnits() override {
     if (NormalUnits.empty()) {
@@ -328,8 +326,8 @@
     if (CUIndex)
       return *CUIndex;
 
-    DataExtractor Data(D.getDWARFObj().getCUIndexSection(),
-                       D.isLittleEndian(), 0);
+    DataExtractor Data(D.getDWARFObj().getCUIndexSection(), D.isLittleEndian(),
+                       0);
     CUIndex = std::make_unique<DWARFUnitIndex>(DW_SECT_INFO);
     if (CUIndex->parse(Data))
       fixupIndex(D, *CUIndex);
@@ -339,8 +337,8 @@
     if (TUIndex)
       return *TUIndex;
 
-    DataExtractor Data(D.getDWARFObj().getTUIndexSection(),
-                       D.isLittleEndian(), 0);
+    DataExtractor Data(D.getDWARFObj().getTUIndexSection(), D.isLittleEndian(),
+                       0);
     TUIndex = std::make_unique<DWARFUnitIndex>(DW_SECT_EXT_TYPES);
     bool isParseSuccessful = TUIndex->parse(Data);
     // If we are parsing TU-index and for .debug_types section we don't need
@@ -364,8 +362,8 @@
     if (Abbrev)
       return Abbrev.get();
 
-    DataExtractor Data(D.getDWARFObj().getAbbrevSection(),
-                       D.isLittleEndian(), 0);
+    DataExtractor Data(D.getDWARFObj().getAbbrevSection(), D.isLittleEndian(),
+                       0);
     Abbrev = std::make_unique<DWARFDebugAbbrev>(Data);
     return Abbrev.get();
   }
@@ -394,8 +392,9 @@
     return Aranges.get();
   }
 
-  Expected<const DWARFDebugLine::LineTable *>
-  getLineTableForUnit(DWARFUnit *U, function_ref<void(Error)> RecoverableErrorHandler) override {
+  Expected<const DWARFDebugLine::LineTable *> getLineTableForUnit(
+      DWARFUnit *U,
+      function_ref<void(Error)> RecoverableErrorHandler) override {
     if (!Line)
       Line = std::make_unique<DWARFDebugLine>();
 
@@ -421,7 +420,6 @@
                             U->isLittleEndian(), U->getAddressByteSize());
     return Line->getOrParseLineTable(Data, stmtOffset, U->getContext(), U,
                                      RecoverableErrorHandler);
-
   }
 
   void clearLineTableForUnit(DWARFUnit *U) override {
@@ -446,20 +444,19 @@
     const DWARFObject &DObj = D.getDWARFObj();
     const DWARFSection &DS = DObj.getFrameSection();
 
-    // There's a "bug" in the DWARFv3 standard with respect to the target address
-    // size within debug frame sections. While DWARF is supposed to be independent
-    // of its container, FDEs have fields with size being "target address size",
-    // which isn't specified in DWARF in general. It's only specified for CUs, but
-    // .eh_frame can appear without a .debug_info section. Follow the example of
-    // other tools (libdwarf) and extract this from the container (ObjectFile
-    // provides this information). This problem is fixed in DWARFv4
-    // See this dwarf-discuss discussion for more details:
+    // There's a "bug" in the DWARFv3 standard with respect to the target
+    // address size within debug frame sections. While DWARF is supposed to be
+    // independent of its container, FDEs have fields with size being "target
+    // address size", which isn't specified in DWARF in general. It's only
+    // specified for CUs, but .eh_frame can appear without a .debug_info
+    // section. Follow the example of other tools (libdwarf) and extract this
+    // from the container (ObjectFile provides this information). This problem
+    // is fixed in DWARFv4 See this dwarf-discuss discussion for more details:
     // http://lists.dwarfstd.org/htdig.cgi/dwarf-discuss-dwarfstd.org/2011-December/001173.html
     DWARFDataExtractor Data(DObj, DS, D.isLittleEndian(),
                             DObj.getAddressSize());
-    auto DF =
-        std::make_unique<DWARFDebugFrame>(D.getArch(), /*IsEH=*/false,
-                                          DS.Address);
+    auto DF = std::make_unique<DWARFDebugFrame>(D.getArch(), /*IsEH=*/false,
+                                                DS.Address);
     if (Error E = DF->parse(Data))
       return std::move(E);
 
@@ -475,9 +472,8 @@
     const DWARFSection &DS = DObj.getEHFrameSection();
     DWARFDataExtractor Data(DObj, DS, D.isLittleEndian(),
                             DObj.getAddressSize());
-    auto DF =
-        std::make_unique<DWARFDebugFrame>(D.getArch(), /*IsEH=*/true,
-                                          DS.Address);
+    auto DF = std::make_unique<DWARFDebugFrame>(D.getArch(), /*IsEH=*/true,
+                                                DS.Address);
     if (Error E = DF->parse(Data))
       return std::move(E);
     EHFrame.swap(DF);
@@ -513,20 +509,17 @@
     const DWARFObject &DObj = D.getDWARFObj();
     return getAccelTable(AppleNames, DObj, DObj.getAppleNamesSection(),
                          DObj.getStrSection(), D.isLittleEndian());
-
   }
   const AppleAcceleratorTable &getAppleTypes() override {
     const DWARFObject &DObj = D.getDWARFObj();
     return getAccelTable(AppleTypes, DObj, DObj.getAppleTypesSection(),
                          DObj.getStrSection(), D.isLittleEndian());
-
   }
   const AppleAcceleratorTable &getAppleNamespaces() override {
     const DWARFObject &DObj = D.getDWARFObj();
     return getAccelTable(AppleNamespaces, DObj,
-                         DObj.getAppleNamespacesSection(),
-                         DObj.getStrSection(), D.isLittleEndian());
-
+                         DObj.getAppleNamespacesSection(), DObj.getStrSection(),
+                         D.isLittleEndian());
   }
   const AppleAcceleratorTable &getAppleObjC() override {
     const DWARFObject &DObj = D.getDWARFObj();
@@ -534,8 +527,7 @@
                          DObj.getStrSection(), D.isLittleEndian());
   }
 
-  std::shared_ptr<DWARFContext>
-  getDWOContext(StringRef AbsolutePath) override {
+  std::shared_ptr<DWARFContext> getDWOContext(StringRef AbsolutePath) override {
     if (auto S = DWP.lock()) {
       DWARFContext *Ctxt = S->Context.get();
       return std::shared_ptr<DWARFContext>(std::move(S), Ctxt);
@@ -596,7 +588,7 @@
   const DenseMap<uint64_t, DWARFTypeUnit *> &getNormalTypeUnitMap() {
     if (!NormalTypeUnits) {
       NormalTypeUnits.emplace();
-      for (const auto &U :D.normal_units()) {
+      for (const auto &U : D.normal_units()) {
         if (DWARFTypeUnit *TU = dyn_cast<DWARFTypeUnit>(U.get()))
           (*NormalTypeUnits)[TU->getTypeHash()] = TU;
       }
@@ -607,7 +599,7 @@
   const DenseMap<uint64_t, DWARFTypeUnit *> &getDWOTypeUnitMap() {
     if (!DWOTypeUnits) {
       DWOTypeUnits.emplace();
-      for (const auto &U :D.dwo_units()) {
+      for (const auto &U : D.dwo_units()) {
         if (DWARFTypeUnit *TU = dyn_cast<DWARFTypeUnit>(U.get()))
           (*DWOTypeUnits)[TU->getTypeHash()] = TU;
       }
@@ -622,113 +614,112 @@
     else
       return getNormalTypeUnitMap();
   }
-
-
 };
 
 class ThreadSafeState : public ThreadUnsafeDWARFContextState {
-  std::recursive_mutex Mutex;
+  llvm::recursive_mutex Mutex;
 
 public:
-  ThreadSafeState(DWARFContext &DC, std::string &DWP) :
-      ThreadUnsafeDWARFContextState(DC, DWP) {}
+  ThreadSafeState(DWARFContext &DC, std::string &DWP)
+      : ThreadUnsafeDWARFContextState(DC, DWP) {}
 
   DWARFUnitVector &getNormalUnits() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getNormalUnits();
   }
   DWARFUnitVector &getDWOUnits(bool Lazy) override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     // We need to not do lazy parsing when we need thread safety as
     // DWARFUnitVector, in lazy mode, will slowly add things to itself and
     // will cause problems in a multi-threaded environment.
     return ThreadUnsafeDWARFContextState::getDWOUnits(false);
   }
   const DWARFUnitIndex &getCUIndex() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getCUIndex();
   }
   const DWARFDebugAbbrev *getDebugAbbrevDWO() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugAbbrevDWO();
   }
 
   const DWARFUnitIndex &getTUIndex() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getTUIndex();
   }
   DWARFGdbIndex &getGdbIndex() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getGdbIndex();
   }
   const DWARFDebugAbbrev *getDebugAbbrev() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugAbbrev();
   }
   const DWARFDebugLoc *getDebugLoc() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugLoc();
   }
   const DWARFDebugAranges *getDebugAranges() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugAranges();
   }
-  Expected<const DWARFDebugLine::LineTable *>
-  getLineTableForUnit(DWARFUnit *U, function_ref<void(Error)> RecoverableErrorHandler) override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
-    return ThreadUnsafeDWARFContextState::getLineTableForUnit(U, RecoverableErrorHandler);
+  Expected<const DWARFDebugLine::LineTable *> getLineTableForUnit(
+      DWARFUnit *U,
+      function_ref<void(Error)> RecoverableErrorHandler) override {
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
+    return ThreadUnsafeDWARFContextState::getLineTableForUnit(
+        U, RecoverableErrorHandler);
   }
   void clearLineTableForUnit(DWARFUnit *U) override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::clearLineTableForUnit(U);
   }
   Expected<const DWARFDebugFrame *> getDebugFrame() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugFrame();
   }
   Expected<const DWARFDebugFrame *> getEHFrame() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getEHFrame();
   }
   const DWARFDebugMacro *getDebugMacinfo() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugMacinfo();
   }
   const DWARFDebugMacro *getDebugMacinfoDWO() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugMacinfoDWO();
   }
   const DWARFDebugMacro *getDebugMacro() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugMacro();
   }
   const DWARFDebugMacro *getDebugMacroDWO() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugMacroDWO();
   }
   const DWARFDebugNames &getDebugNames() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDebugNames();
   }
   const AppleAcceleratorTable &getAppleNames() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getAppleNames();
   }
   const AppleAcceleratorTable &getAppleTypes() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getAppleTypes();
   }
   const AppleAcceleratorTable &getAppleNamespaces() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getAppleNamespaces();
   }
   const AppleAcceleratorTable &getAppleObjC() override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getAppleObjC();
   }
-  std::shared_ptr<DWARFContext>
-  getDWOContext(StringRef AbsolutePath) override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+  std::shared_ptr<DWARFContext> getDWOContext(StringRef AbsolutePath) override {
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getDWOContext(AbsolutePath);
   }
 
@@ -736,26 +727,23 @@
 
   const DenseMap<uint64_t, DWARFTypeUnit *> &
   getTypeUnitMap(bool IsDWO) override {
-    std::unique_lock<std::recursive_mutex> LockGuard(Mutex);
+    llvm::unique_lock<llvm::recursive_mutex> LockGuard(Mutex);
     return ThreadUnsafeDWARFContextState::getTypeUnitMap(IsDWO);
   }
 };
 
-
-
 DWARFContext::DWARFContext(std::unique_ptr<const DWARFObject> DObj,
                            std::string DWPName,
                            std::function<void(Error)> RecoverableErrorHandler,
                            std::function<void(Error)> WarningHandler,
                            bool ThreadSafe)
-    : DIContext(CK_DWARF),
-      RecoverableErrorHandler(RecoverableErrorHandler),
+    : DIContext(CK_DWARF), RecoverableErrorHandler(RecoverableErrorHandler),
       WarningHandler(WarningHandler), DObj(std::move(DObj)) {
-        if (ThreadSafe)
-          State = std::make_unique<ThreadSafeState>(*this, DWPName);
-        else
-          State = std::make_unique<ThreadUnsafeDWARFContextState>(*this, DWPName);
-      }
+  if (ThreadSafe)
+    State = std::make_unique<ThreadSafeState>(*this, DWPName);
+  else
+    State = std::make_unique<ThreadUnsafeDWARFContextState>(*this, DWPName);
+}
 
 DWARFContext::~DWARFContext() = default;
 
@@ -772,7 +760,7 @@
         return;
       }
       OS << "UUID: ";
-      memcpy(&UUID, LC.Ptr+sizeof(LC.C), sizeof(UUID));
+      memcpy(&UUID, LC.Ptr + sizeof(LC.C), sizeof(UUID));
       OS.write_uuid(UUID);
       Triple T = MachO->getArchTriple();
       OS << " (" << T.getArchName() << ')';
@@ -945,7 +933,6 @@
   }
 }
 
-
 static void dumpLoclistsSection(raw_ostream &OS, DIDumpOptions DumpOpts,
                                 DWARFDataExtractor Data, const DWARFObject &Obj,
                                 std::optional<uint64_t> DumpOffset) {
@@ -1227,8 +1214,8 @@
 
   if (shouldDump(Explicit, ".debug_addr", DIDT_ID_DebugAddr,
                  DObj->getAddrSection().Data)) {
-    DWARFDataExtractor AddrData(*DObj, DObj->getAddrSection(),
-                                   isLittleEndian(), 0);
+    DWARFDataExtractor AddrData(*DObj, DObj->getAddrSection(), isLittleEndian(),
+                                0);
     dumpAddrSection(OS, AddrData, DumpOpts, getMaxVersion(), getCUAddrSize());
   }
 
@@ -1341,8 +1328,7 @@
   DWARFUnitVector &DWOUnits = State->getDWOUnits();
   if (const auto &TUI = getTUIndex()) {
     if (const auto *R = TUI.getFromHash(Hash))
-      return dyn_cast_or_null<DWARFTypeUnit>(
-          DWOUnits.getUnitForIndexEntry(*R));
+      return dyn_cast_or_null<DWARFTypeUnit>(DWOUnits.getUnitForIndexEntry(*R));
     return nullptr;
   }
   const DenseMap<uint64_t, DWARFTypeUnit *> &Map = State->getTypeUnitMap(IsDWO);
@@ -1407,17 +1393,11 @@
   return Success;
 }
 
-const DWARFUnitIndex &DWARFContext::getCUIndex() {
-  return State->getCUIndex();
-}
+const DWARFUnitIndex &DWARFContext::getCUIndex() { return State->getCUIndex(); }
 
-const DWARFUnitIndex &DWARFContext::getTUIndex() {
-  return State->getTUIndex();
-}
+const DWARFUnitIndex &DWARFContext::getTUIndex() { return State->getTUIndex(); }
 
-DWARFGdbIndex &DWARFContext::getGdbIndex() {
-  return State->getGdbIndex();
-}
+DWARFGdbIndex &DWARFContext::getGdbIndex() { return State->getGdbIndex(); }
 
 const DWARFDebugAbbrev *DWARFContext::getDebugAbbrev() {
   return State->getDebugAbbrev();
@@ -1459,7 +1439,6 @@
   return State->getDebugMacinfoDWO();
 }
 
-
 const DWARFDebugNames &DWARFContext::getDebugNames() {
   return State->getDebugNames();
 }
@@ -2116,7 +2095,7 @@
         consumeError(NameOrErr.takeError());
 
       ++SectionAmountMap[Name];
-      SectionNames.push_back({ Name, true });
+      SectionNames.push_back({Name, true});
 
       // Skip BSS and Virtual sections, they aren't interesting.
       if (Section.isBSS() || Section.isVirtual())
@@ -2351,17 +2330,19 @@
 
   StringRef getAbbrevSection() const override { return AbbrevSection; }
   const DWARFSection &getLocSection() const override { return LocSection; }
-  const DWARFSection &getLoclistsSection() const override { return LoclistsSection; }
-  StringRef getArangesSection() const override { return ArangesSection; }
-  const DWARFSection &getFrameSection() const override {
-    return FrameSection;
+  const DWARFSection &getLoclistsSection() const override {
+    return LoclistsSection;
   }
+  StringRef getArangesSection() const override { return ArangesSection; }
+  const DWARFSection &getFrameSection() const override { return FrameSection; }
   const DWARFSection &getEHFrameSection() const override {
     return EHFrameSection;
   }
   const DWARFSection &getLineSection() const override { return LineSection; }
   StringRef getStrSection() const override { return StrSection; }
-  const DWARFSection &getRangesSection() const override { return RangesSection; }
+  const DWARFSection &getRangesSection() const override {
+    return RangesSection;
+  }
   const DWARFSection &getRnglistsSection() const override {
     return RnglistsSection;
   }
@@ -2369,8 +2350,12 @@
   StringRef getMacroDWOSection() const override { return MacroDWOSection; }
   StringRef getMacinfoSection() const override { return MacinfoSection; }
   StringRef getMacinfoDWOSection() const override { return MacinfoDWOSection; }
-  const DWARFSection &getPubnamesSection() const override { return PubnamesSection; }
-  const DWARFSection &getPubtypesSection() const override { return PubtypesSection; }
+  const DWARFSection &getPubnamesSection() const override {
+    return PubnamesSection;
+  }
+  const DWARFSection &getPubtypesSection() const override {
+    return PubtypesSection;
+  }
   const DWARFSection &getGnuPubnamesSection() const override {
     return GnuPubnamesSection;
   }
@@ -2389,9 +2374,7 @@
   const DWARFSection &getAppleObjCSection() const override {
     return AppleObjCSection;
   }
-  const DWARFSection &getNamesSection() const override {
-    return NamesSection;
-  }
+  const DWARFSection &getNamesSection() const override { return NamesSection; }
 
   StringRef getFileName() const override { return FileName; }
   uint8_t getAddressSize() const override { return AddressSize; }
@@ -2408,28 +2391,22 @@
 };
 } // namespace
 
-std::unique_ptr<DWARFContext>
-DWARFContext::create(const object::ObjectFile &Obj,
-                     ProcessDebugRelocations RelocAction,
-                     const LoadedObjectInfo *L, std::string DWPName,
-                     std::function<void(Error)> RecoverableErrorHandler,
-                     std::function<void(Error)> WarningHandler,
-                     bool ThreadSafe) {
+std::unique_ptr<DWARFContext> DWARFContext::create(
+    const object::ObjectFile &Obj, ProcessDebugRelocations RelocAction,
+    const LoadedObjectInfo *L, std::string DWPName,
+    std::function<void(Error)> RecoverableErrorHandler,
+    std::function<void(Error)> WarningHandler, bool ThreadSafe) {
   auto DObj = std::make_unique<DWARFObjInMemory>(
       Obj, L, RecoverableErrorHandler, WarningHandler, RelocAction);
-  return std::make_unique<DWARFContext>(std::move(DObj),
-                                        std::move(DWPName),
-                                        RecoverableErrorHandler,
-                                        WarningHandler,
+  return std::make_unique<DWARFContext>(std::move(DObj), std::move(DWPName),
+                                        RecoverableErrorHandler, WarningHandler,
                                         ThreadSafe);
 }
 
-std::unique_ptr<DWARFContext>
-DWARFContext::create(const StringMap<std::unique_ptr<MemoryBuffer>> &Sections,
-                     uint8_t AddrSize, bool isLittleEndian,
-                     std::function<void(Error)> RecoverableErrorHandler,
-                     std::function<void(Error)> WarningHandler,
-                     bool ThreadSafe) {
+std::unique_ptr<DWARFContext> DWARFContext::create(
+    const StringMap<std::unique_ptr<MemoryBuffer>> &Sections, uint8_t AddrSize,
+    bool isLittleEndian, std::function<void(Error)> RecoverableErrorHandler,
+    std::function<void(Error)> WarningHandler, bool ThreadSafe) {
   auto DObj =
       std::make_unique<DWARFObjInMemory>(Sections, AddrSize, isLittleEndian);
   return std::make_unique<DWARFContext>(
diff '--color=auto' -r -u llvm/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp build/llvm-src/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp
--- llvm/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp	2023-12-29 16:36:23.295552437 +0100
+++ build/llvm-src/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp	2024-01-02 03:15:13.631395241 +0100
@@ -6,7 +6,6 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include <thread>
 #include <unordered_set>
 
 #include "llvm/DebugInfo/DIContext.h"
@@ -83,7 +82,6 @@
   }
 };
 
-
 static DWARFDie GetParentDeclContextDIE(DWARFDie &Die) {
   if (DWARFDie SpecDie =
           Die.getAttributeValueAsReferencedDie(dwarf::DW_AT_specification)) {
@@ -171,7 +169,7 @@
         // templates
         if (ParentName.front() == '<' && ParentName.back() == '>')
           Name = "{" + ParentName.substr(1, ParentName.size() - 2).str() + "}" +
-                "::" + Name;
+                 "::" + Name;
         else
           Name = ParentName.str() + "::" + Name;
       }
@@ -310,7 +308,6 @@
   const object::SectionedAddress SecAddress{
       StartAddress, object::SectionedAddress::UndefSection};
 
-
   if (!CUI.LineTable->lookupAddressRange(SecAddress, RangeSize, RowVector)) {
     // If we have a DW_TAG_subprogram but no line entries, fall back to using
     // the DW_AT_decl_file an d DW_AT_decl_line if we have both attributes.
@@ -369,8 +366,9 @@
       if (RowAddress < FI.Range.start()) {
         if (Log) {
           *Log << "error: DIE has a start address whose LowPC is between the "
-                  "line table Row[" << RowIndex << "] with address "
-               << HEX64(RowAddress) << " and the next one.\n";
+                  "line table Row["
+               << RowIndex << "] with address " << HEX64(RowAddress)
+               << " and the next one.\n";
           Die.dump(*Log, 0, DIDumpOptions::getForSingleDIE());
         }
         RowAddress = FI.Range.start();
@@ -408,7 +406,7 @@
     // Skip multiple line entries for the same file and line.
     auto LastLE = FI.OptLineTable->last();
     if (LastLE && LastLE->File == FileIdx && LastLE->Line == Row.Line)
-        continue;
+      continue;
     // Only push a row if it isn't an end sequence. End sequence markers are
     // included for the last address in a function or the last contiguous
     // address in a sequence.
@@ -519,7 +517,7 @@
         if (FI.Inline->Children.empty()) {
           if (WarnIfEmpty && OS && !Gsym.isQuiet()) {
             *OS << "warning: DIE contains inline function information that has "
-                  "no valid ranges, removing inline information:\n";
+                   "no valid ranges, removing inline information:\n";
             Die.dump(*OS, 0, DIDumpOptions::getForSingleDIE());
           }
           FI.Inline = std::nullopt;
@@ -581,7 +579,7 @@
     pool.wait();
 
     // Now convert all DWARF to GSYM in a thread pool.
-    std::mutex LogMutex;
+    llvm::mutex LogMutex;
     for (const auto &CU : DICtx.compile_units()) {
       DWARFDie Die = getDie(*CU);
       if (Die) {
@@ -589,11 +587,11 @@
         pool.async([this, CUI, &LogMutex, OS, Die]() mutable {
           std::string ThreadLogStorage;
           raw_string_ostream ThreadOS(ThreadLogStorage);
-          handleDie(OS ? &ThreadOS: nullptr, CUI, Die);
+          handleDie(OS ? &ThreadOS : nullptr, CUI, Die);
           ThreadOS.flush();
           if (OS && !ThreadLogStorage.empty()) {
             // Print ThreadLogStorage lines into an actual stream under a lock
-            std::lock_guard<std::mutex> guard(LogMutex);
+            llvm::lock_guard<llvm::mutex> guard(LogMutex);
             *OS << ThreadLogStorage;
           }
         });
@@ -622,14 +620,14 @@
   for (uint32_t I = 0; I < NumAddrs; ++I) {
     auto FuncAddr = Gsym->getAddress(I);
     if (!FuncAddr)
-        return createStringError(std::errc::invalid_argument,
-                                  "failed to extract address[%i]", I);
+      return createStringError(std::errc::invalid_argument,
+                               "failed to extract address[%i]", I);
 
     auto FI = Gsym->getFunctionInfo(*FuncAddr);
     if (!FI)
-      return createStringError(std::errc::invalid_argument,
-                            "failed to extract function info for address 0x%"
-                            PRIu64, *FuncAddr);
+      return createStringError(
+          std::errc::invalid_argument,
+          "failed to extract function info for address 0x%" PRIu64, *FuncAddr);
 
     for (auto Addr = *FuncAddr; Addr < *FuncAddr + FI->size(); ++Addr) {
       const object::SectionedAddress SectAddr{
@@ -638,12 +636,10 @@
       if (!LR)
         return LR.takeError();
 
-      auto DwarfInlineInfos =
-          DICtx.getInliningInfoForAddress(SectAddr, DLIS);
+      auto DwarfInlineInfos = DICtx.getInliningInfoForAddress(SectAddr, DLIS);
       uint32_t NumDwarfInlineInfos = DwarfInlineInfos.getNumberOfFrames();
       if (NumDwarfInlineInfos == 0) {
-        DwarfInlineInfos.addFrame(
-            DICtx.getLineInfoForAddress(SectAddr, DLIS));
+        DwarfInlineInfos.addFrame(DICtx.getLineInfoForAddress(SectAddr, DLIS));
       }
 
       // Check for 1 entry that has no file and line info
@@ -664,19 +660,17 @@
               << dii.FileName << ':' << dii.Line << '\n';
         }
         Log << "    " << LR->Locations.size() << " GSYM frames:\n";
-        for (size_t Idx = 0, count = LR->Locations.size();
-              Idx < count; ++Idx) {
+        for (size_t Idx = 0, count = LR->Locations.size(); Idx < count; ++Idx) {
           const auto &gii = LR->Locations[Idx];
-          Log << "    [" << Idx << "]: " << gii.Name << " @ " << gii.Dir
-              << '/' << gii.Base << ':' << gii.Line << '\n';
+          Log << "    [" << Idx << "]: " << gii.Name << " @ " << gii.Dir << '/'
+              << gii.Base << ':' << gii.Line << '\n';
         }
         DwarfInlineInfos = DICtx.getInliningInfoForAddress(SectAddr, DLIS);
         Gsym->dump(Log, *FI);
         continue;
       }
 
-      for (size_t Idx = 0, count = LR->Locations.size(); Idx < count;
-            ++Idx) {
+      for (size_t Idx = 0, count = LR->Locations.size(); Idx < count; ++Idx) {
         const auto &gii = LR->Locations[Idx];
         if (Idx < NumDwarfInlineInfos) {
           const auto &dii = DwarfInlineInfos.getFrame(Idx);
diff '--color=auto' -r -u llvm/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp build/llvm-src/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp
--- llvm/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp	2023-12-29 16:36:23.295552437 +0100
+++ build/llvm-src/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp	2024-01-02 03:15:13.631395241 +0100
@@ -38,7 +38,7 @@
 }
 
 uint32_t GsymCreator::insertFileEntry(FileEntry FE) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   const auto NextIndex = Files.size();
   // Find FE in hash map and insert if not present.
   auto R = FileEntryToIndex.insert(std::make_pair(FE, NextIndex));
@@ -74,7 +74,7 @@
 }
 
 llvm::Error GsymCreator::encode(FileWriter &O) const {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   if (Funcs.empty())
     return createStringError(std::errc::invalid_argument,
                              "no functions to encode");
@@ -186,7 +186,7 @@
 }
 
 llvm::Error GsymCreator::finalize(llvm::raw_ostream &OS) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   if (Finalized)
     return createStringError(std::errc::invalid_argument, "already finalized");
   Finalized = true;
@@ -227,7 +227,7 @@
       std::vector<FunctionInfo> FinalizedFuncs;
       FinalizedFuncs.reserve(Funcs.size());
       FinalizedFuncs.emplace_back(std::move(Funcs.front()));
-      for (size_t Idx=1; Idx < NumBefore; ++Idx) {
+      for (size_t Idx = 1; Idx < NumBefore; ++Idx) {
         FunctionInfo &Prev = FinalizedFuncs.back();
         FunctionInfo &Curr = Funcs[Idx];
         // Empty ranges won't intersect, but we still need to
@@ -248,9 +248,9 @@
                 if (!Quiet) {
                   OS << "warning: same address range contains "
                         "different debug "
-                    << "info. Removing:\n"
-                    << Prev << "\nIn favor of this one:\n"
-                    << Curr << "\n";
+                     << "info. Removing:\n"
+                     << Prev << "\nIn favor of this one:\n"
+                     << Curr << "\n";
                 }
               }
               // We want to swap the current entry with the previous since
@@ -261,13 +261,14 @@
           } else {
             if (!Quiet) { // print warnings about overlaps
               OS << "warning: function ranges overlap:\n"
-                << Prev << "\n"
-                << Curr << "\n";
+                 << Prev << "\n"
+                 << Curr << "\n";
             }
             FinalizedFuncs.emplace_back(std::move(Curr));
           }
         } else {
-          if (Prev.Range.size() == 0 && Curr.Range.contains(Prev.Range.start())) {
+          if (Prev.Range.size() == 0 &&
+              Curr.Range.contains(Prev.Range.start())) {
             // Symbols on macOS don't have address ranges, so if the range
             // doesn't match and the size is zero, then we replace the empty
             // symbol function info with the current one.
@@ -280,18 +281,18 @@
       std::swap(Funcs, FinalizedFuncs);
     }
     // If our last function info entry doesn't have a size and if we have valid
-    // text ranges, we should set the size of the last entry since any search for
-    // a high address might match our last entry. By fixing up this size, we can
-    // help ensure we don't cause lookups to always return the last symbol that
-    // has no size when doing lookups.
+    // text ranges, we should set the size of the last entry since any search
+    // for a high address might match our last entry. By fixing up this size, we
+    // can help ensure we don't cause lookups to always return the last symbol
+    // that has no size when doing lookups.
     if (!Funcs.empty() && Funcs.back().Range.size() == 0 && ValidTextRanges) {
-      if (auto Range =
-              ValidTextRanges->getRangeThatContains(Funcs.back().Range.start())) {
+      if (auto Range = ValidTextRanges->getRangeThatContains(
+              Funcs.back().Range.start())) {
         Funcs.back().Range = {Funcs.back().Range.start(), Range->end()};
       }
     }
     OS << "Pruned " << NumBefore - Funcs.size() << " functions, ended with "
-      << Funcs.size() << " total\n";
+       << Funcs.size() << " total\n";
   }
   return Error::success();
 }
@@ -309,7 +310,7 @@
 
   // The hash can be calculated outside the lock.
   CachedHashStringRef CHStr(S);
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   if (Copy) {
     // We need to provide backing storage for the string if requested
     // since StringTableBuilder stores references to strings. Any string
@@ -331,13 +332,13 @@
 }
 
 void GsymCreator::addFunctionInfo(FunctionInfo &&FI) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   Funcs.emplace_back(std::move(FI));
 }
 
 void GsymCreator::forEachFunctionInfo(
     std::function<bool(FunctionInfo &)> const &Callback) {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   for (auto &FI : Funcs) {
     if (!Callback(FI))
       break;
@@ -346,7 +347,7 @@
 
 void GsymCreator::forEachFunctionInfo(
     std::function<bool(const FunctionInfo &)> const &Callback) const {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   for (const auto &FI : Funcs) {
     if (!Callback(FI))
       break;
@@ -354,7 +355,7 @@
 }
 
 size_t GsymCreator::getNumFunctionInfos() const {
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   return Funcs.size();
 }
 
@@ -392,10 +393,14 @@
 
 uint64_t GsymCreator::getMaxAddressOffset() const {
   switch (getAddressOffsetSize()) {
-    case 1: return UINT8_MAX;
-    case 2: return UINT16_MAX;
-    case 4: return UINT32_MAX;
-    case 8: return UINT64_MAX;
+  case 1:
+    return UINT8_MAX;
+  case 2:
+    return UINT16_MAX;
+  case 4:
+    return UINT32_MAX;
+  case 8:
+    return UINT64_MAX;
   }
   llvm_unreachable("invalid address offset");
 }
@@ -437,11 +442,12 @@
 void GsymCreator::fixupInlineInfo(const GsymCreator &SrcGC, InlineInfo &II) {
   II.Name = copyString(SrcGC, II.Name);
   II.CallFile = copyFile(SrcGC, II.CallFile);
-  for (auto &ChildII: II.Children)
+  for (auto &ChildII : II.Children)
     fixupInlineInfo(SrcGC, ChildII);
 }
 
-uint64_t GsymCreator::copyFunctionInfo(const GsymCreator &SrcGC, size_t FuncIdx) {
+uint64_t GsymCreator::copyFunctionInfo(const GsymCreator &SrcGC,
+                                       size_t FuncIdx) {
   // To copy a function info we need to copy any files and strings over into
   // this GsymCreator and then copy the function info and update the string
   // table offsets to match the new offsets.
@@ -458,7 +464,7 @@
     // from SrcGC and must be converted to file indexes from this GsymCreator.
     LineTable &DstLT = DstFI.OptLineTable.value();
     const size_t NumLines = DstLT.size();
-    for (size_t I=0; I<NumLines; ++I) {
+    for (size_t I = 0; I < NumLines; ++I) {
       LineEntry &LE = DstLT.get(I);
       LE.File = copyFile(SrcGC, LE.File);
     }
@@ -470,7 +476,7 @@
     // Fixup all strings and files in the copied inline information.
     fixupInlineInfo(SrcGC, *DstFI.Inline);
   }
-  std::lock_guard<std::mutex> Guard(Mutex);
+  llvm::lock_guard<llvm::mutex> Guard(Mutex);
   Funcs.emplace_back(DstFI);
   return Funcs.back().cacheEncoding();
 }
@@ -537,10 +543,11 @@
     const uint64_t HeaderAndTableSize = GC->calculateHeaderAndTableSize();
     if (HeaderAndTableSize + SegmentFuncInfosSize >= SegmentSize) {
       if (SegmentFuncInfosSize == 0)
-        return createStringError(std::errc::invalid_argument,
-                                 "a segment size of %" PRIu64 " is to small to "
-                                 "fit any function infos, specify a larger value",
-                                 SegmentSize);
+        return createStringError(
+            std::errc::invalid_argument,
+            "a segment size of %" PRIu64 " is to small to "
+            "fit any function infos, specify a larger value",
+            SegmentSize);
 
       break;
     }
diff '--color=auto' -r -u llvm/llvm/lib/Debuginfod/Debuginfod.cpp build/llvm-src/llvm/lib/Debuginfod/Debuginfod.cpp
--- llvm/llvm/lib/Debuginfod/Debuginfod.cpp	2023-12-29 21:47:41.859673682 +0100
+++ build/llvm-src/llvm/lib/Debuginfod/Debuginfod.cpp	2024-01-02 03:15:13.631395241 +0100
@@ -38,11 +38,11 @@
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/ThreadPool.h"
+#include "llvm/Support/thread.h"
 #include "llvm/Support/xxhash.h"
 
 #include <atomic>
 #include <optional>
-#include <thread>
 
 namespace llvm {
 
@@ -69,12 +69,12 @@
 }
 
 SmallVector<StringRef> getDefaultDebuginfodUrls() {
-  std::shared_lock<llvm::sys::RWMutex> ReadGuard(UrlsMutex);
+  llvm::shared_lock<llvm::sys::RWMutex> ReadGuard(UrlsMutex);
   if (!DebuginfodUrls) {
     // Only read from the environment variable if the user hasn't already
     // set the value
     ReadGuard.unlock();
-    std::unique_lock<llvm::sys::RWMutex> WriteGuard(UrlsMutex);
+    llvm::unique_lock<llvm::sys::RWMutex> WriteGuard(UrlsMutex);
     DebuginfodUrls = SmallVector<StringRef>();
     if (const char *DebuginfodUrlsEnv = std::getenv("DEBUGINFOD_URLS")) {
       StringRef(DebuginfodUrlsEnv)
@@ -88,7 +88,7 @@
 
 // Set the default debuginfod URL list, override the environment variable
 void setDefaultDebuginfodUrls(const SmallVector<StringRef> &URLs) {
-  std::unique_lock<llvm::sys::RWMutex> WriteGuard(UrlsMutex);
+  llvm::unique_lock<llvm::sys::RWMutex> WriteGuard(UrlsMutex);
   DebuginfodUrls = URLs;
 }
 
@@ -310,7 +310,7 @@
 
 void DebuginfodLog::push(DebuginfodLogEntry Entry) {
   {
-    std::lock_guard<std::mutex> Guard(QueueMutex);
+    llvm::lock_guard<llvm::mutex> Guard(QueueMutex);
     LogEntryQueue.push(Entry);
   }
   QueueCondition.notify_one();
@@ -318,11 +318,11 @@
 
 DebuginfodLogEntry DebuginfodLog::pop() {
   {
-    std::unique_lock<std::mutex> Guard(QueueMutex);
+    llvm::unique_lock<llvm::mutex> Guard(QueueMutex);
     // Wait for messages to be pushed into the queue.
     QueueCondition.wait(Guard, [&] { return !LogEntryQueue.empty(); });
   }
-  std::lock_guard<std::mutex> Guard(QueueMutex);
+  llvm::lock_guard<llvm::mutex> Guard(QueueMutex);
   if (!LogEntryQueue.size())
     llvm_unreachable("Expected message in the queue.");
 
@@ -340,7 +340,7 @@
 }
 
 Error DebuginfodCollection::update() {
-  std::lock_guard<sys::Mutex> Guard(UpdateMutex);
+  llvm::lock_guard<sys::Mutex> Guard(UpdateMutex);
   if (UpdateTimer.isRunning())
     UpdateTimer.stopTimer();
   UpdateTimer.clear();
@@ -371,7 +371,7 @@
   while (true) {
     if (Error Err = update())
       return Err;
-    std::this_thread::sleep_for(Interval);
+    llvm::this_thread::sleep_for(Interval);
   }
   llvm_unreachable("updateForever loop should never end");
 }
@@ -396,7 +396,7 @@
 Error DebuginfodCollection::findBinaries(StringRef Path) {
   std::error_code EC;
   sys::fs::recursive_directory_iterator I(Twine(Path), EC), E;
-  std::mutex IteratorMutex;
+  llvm::mutex IteratorMutex;
   ThreadPoolTaskGroup IteratorGroup(Pool);
   for (unsigned WorkerIndex = 0; WorkerIndex < Pool.getThreadCount();
        WorkerIndex++) {
@@ -405,7 +405,7 @@
       while (true) {
         {
           // Check if iteration is over or there is an error during iteration
-          std::lock_guard<std::mutex> Guard(IteratorMutex);
+          llvm::lock_guard<llvm::mutex> Guard(IteratorMutex);
           if (I == E || EC)
             return;
           // Grab a file path from the directory iterator and advance the
@@ -441,17 +441,17 @@
 
         std::string IDString = buildIDToString(ID);
         if (Object->hasDebugInfo()) {
-          std::lock_guard<sys::RWMutex> DebugBinariesGuard(DebugBinariesMutex);
+          llvm::lock_guard<sys::RWMutex> DebugBinariesGuard(DebugBinariesMutex);
           (void)DebugBinaries.try_emplace(IDString, std::move(FilePath));
         } else {
-          std::lock_guard<sys::RWMutex> BinariesGuard(BinariesMutex);
+          llvm::lock_guard<sys::RWMutex> BinariesGuard(BinariesMutex);
           (void)Binaries.try_emplace(IDString, std::move(FilePath));
         }
       }
     });
   }
   IteratorGroup.wait();
-  std::unique_lock<std::mutex> Guard(IteratorMutex);
+  llvm::unique_lock<llvm::mutex> Guard(IteratorMutex);
   if (EC)
     return errorCodeToError(EC);
   return Error::success();
@@ -460,7 +460,7 @@
 Expected<std::optional<std::string>>
 DebuginfodCollection::getBinaryPath(BuildIDRef ID) {
   Log.push("getting binary path of ID " + buildIDToString(ID));
-  std::shared_lock<sys::RWMutex> Guard(BinariesMutex);
+  llvm::shared_lock<sys::RWMutex> Guard(BinariesMutex);
   auto Loc = Binaries.find(buildIDToString(ID));
   if (Loc != Binaries.end()) {
     std::string Path = Loc->getValue();
@@ -472,7 +472,7 @@
 Expected<std::optional<std::string>>
 DebuginfodCollection::getDebugBinaryPath(BuildIDRef ID) {
   Log.push("getting debug binary path of ID " + buildIDToString(ID));
-  std::shared_lock<sys::RWMutex> Guard(DebugBinariesMutex);
+  llvm::shared_lock<sys::RWMutex> Guard(DebugBinariesMutex);
   auto Loc = DebugBinaries.find(buildIDToString(ID));
   if (Loc != DebugBinaries.end()) {
     std::string Path = Loc->getValue();
diff '--color=auto' -r -u llvm/llvm/lib/DWARFLinker/DWARFLinker.cpp build/llvm-src/llvm/lib/DWARFLinker/DWARFLinker.cpp
--- llvm/llvm/lib/DWARFLinker/DWARFLinker.cpp	2023-12-29 21:47:41.855673461 +0100
+++ build/llvm-src/llvm/lib/DWARFLinker/DWARFLinker.cpp	2024-01-02 03:15:13.631395241 +0100
@@ -1357,9 +1357,9 @@
   //     independently by the linker).
   //   - If address relocated in an inline_subprogram that happens at the
   //     beginning of its inlining function.
-  //  To avoid above cases and to not apply relocation twice (in applyValidRelocs
-  //  and here), read address attribute from InputDIE and apply Info.PCOffset
-  //  here.
+  //  To avoid above cases and to not apply relocation twice (in
+  //  applyValidRelocs and here), read address attribute from InputDIE and apply
+  //  Info.PCOffset here.
 
   std::optional<DWARFFormValue> AddrAttribute = InputDIE.find(AttrSpec.Attr);
   if (!AddrAttribute)
@@ -2040,8 +2040,7 @@
 }
 
 void DWARFLinker::DIECloner::emitDebugAddrSection(
-    CompileUnit &Unit,
-    const uint16_t DwarfVersion) const {
+    CompileUnit &Unit, const uint16_t DwarfVersion) const {
 
   if (LLVM_UNLIKELY(Linker.Options.Update))
     return;
@@ -2787,8 +2786,8 @@
 
   // These variables manage the list of processed object files.
   // The mutex and condition variable are to ensure that this is thread safe.
-  std::mutex ProcessedFilesMutex;
-  std::condition_variable ProcessedFilesConditionVariable;
+  llvm::mutex ProcessedFilesMutex;
+  llvm::condition_variable ProcessedFilesConditionVariable;
   BitVector ProcessedFiles(NumObjects, false);
 
   //  Analyzing the context info is particularly expensive so it is executed in
@@ -2912,7 +2911,7 @@
     for (unsigned I = 0, E = NumObjects; I != E; ++I) {
       AnalyzeLambda(I);
 
-      std::unique_lock<std::mutex> LockGuard(ProcessedFilesMutex);
+      llvm::unique_lock<llvm::mutex> LockGuard(ProcessedFilesMutex);
       ProcessedFiles.set(I);
       ProcessedFilesConditionVariable.notify_one();
     }
@@ -2921,7 +2920,7 @@
   auto CloneAll = [&]() {
     for (unsigned I = 0, E = NumObjects; I != E; ++I) {
       {
-        std::unique_lock<std::mutex> LockGuard(ProcessedFilesMutex);
+        llvm::unique_lock<llvm::mutex> LockGuard(ProcessedFilesMutex);
         if (!ProcessedFiles[I]) {
           ProcessedFilesConditionVariable.wait(
               LockGuard, [&]() { return ProcessedFiles[I]; });
@@ -3039,7 +3038,6 @@
 void DWARFLinker::verifyInput(const DWARFFile &File) {
   assert(File.Dwarf);
 
-
   std::string Buffer;
   raw_string_ostream OS(Buffer);
   DIDumpOptions DumpOpts;
diff '--color=auto' -r -u llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp
--- llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp	2023-12-29 21:47:41.856673516 +0100
+++ build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.cpp	2024-01-02 03:15:13.632395297 +0100
@@ -437,7 +437,7 @@
 
 void CompileUnit::addFunctionRange(uint64_t FuncLowPc, uint64_t FuncHighPc,
                                    int64_t PcOffset) {
-  std::lock_guard<std::mutex> Guard(RangesMutex);
+  llvm::lock_guard<llvm::mutex> Guard(RangesMutex);
 
   Ranges.insert({FuncLowPc, FuncHighPc}, PcOffset);
   if (LowPc)
@@ -448,7 +448,7 @@
 }
 
 void CompileUnit::addLabelLowPc(uint64_t LabelLowPc, int64_t PcOffset) {
-  std::lock_guard<std::mutex> Guard(LabelsMutex);
+  llvm::lock_guard<llvm::mutex> Guard(LabelsMutex);
   Labels.insert({LabelLowPc, PcOffset});
 }
 
diff '--color=auto' -r -u llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.h build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.h
--- llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.h	2023-12-29 21:47:41.856673516 +0100
+++ build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerCompileUnit.h	2024-01-02 03:15:13.632395297 +0100
@@ -704,12 +704,12 @@
   /// associated with the PC offset to apply to the addresses to get
   /// the linked address.
   RangesTy Ranges;
-  std::mutex RangesMutex;
+  llvm::mutex RangesMutex;
 
   /// The DW_AT_low_pc of each DW_TAG_label.
   using LabelMapTy = SmallDenseMap<uint64_t, uint64_t, 1>;
   LabelMapTy Labels;
-  std::mutex LabelsMutex;
+  llvm::mutex LabelsMutex;
 
   /// This field keeps current stage of overall compile unit processing.
   std::atomic<Stage> Stage;
diff '--color=auto' -r -u llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.h build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.h
--- llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.h	2023-12-29 21:47:41.857673571 +0100
+++ build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerImpl.h	2024-01-02 03:15:13.632395297 +0100
@@ -342,7 +342,7 @@
 
   /// Mapping the PCM filename to the DwoId.
   StringMap<uint64_t> ClangModules;
-  std::mutex ClangModulesMutex;
+  llvm::mutex ClangModulesMutex;
 
   /// Type unit.
   std::unique_ptr<TypeUnit> ArtificialTypeUnit;
diff '--color=auto' -r -u llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerTypeUnit.h build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerTypeUnit.h
--- llvm/llvm/lib/DWARFLinkerParallel/DWARFLinkerTypeUnit.h	2023-12-29 21:47:41.857673571 +0100
+++ build/llvm-src/llvm/lib/DWARFLinkerParallel/DWARFLinkerTypeUnit.h	2024-01-02 03:15:13.632395297 +0100
@@ -67,7 +67,7 @@
 
   /// Returns index for the specified \p String inside .debug_str_offsets.
   uint64_t getDebugStrIndex(const StringEntry *String) override {
-    std::unique_lock<std::mutex> LockGuard(DebugStringIndexMapMutex);
+    llvm::unique_lock<llvm::mutex> LockGuard(DebugStringIndexMapMutex);
     return DebugStringIndexMap.getValueIndex(String);
   }
 
@@ -129,7 +129,7 @@
   ArrayList<TypeUnitAccelInfo> AcceleratorRecords;
 
   /// Guard for DebugStringIndexMap.
-  std::mutex DebugStringIndexMapMutex;
+  llvm::mutex DebugStringIndexMapMutex;
 };
 
 } // end of namespace dwarflinker_parallel
diff '--color=auto' -r -u llvm/llvm/lib/LTO/LTO.cpp build/llvm-src/llvm/lib/LTO/LTO.cpp
--- llvm/llvm/lib/LTO/LTO.cpp	2023-12-29 21:47:41.872674399 +0100
+++ build/llvm-src/llvm/lib/LTO/LTO.cpp	2024-01-02 03:15:13.632395297 +0100
@@ -232,7 +232,8 @@
   };
 
   auto AddUsedThings = [&](GlobalValueSummary *GS) {
-    if (!GS) return;
+    if (!GS)
+      return;
     AddUnsigned(GS->getVisibility());
     AddUnsigned(GS->isLive());
     AddUnsigned(GS->canAutoHide());
@@ -566,9 +567,7 @@
   return std::move(File);
 }
 
-StringRef InputFile::getName() const {
-  return Mods[0].getModuleIdentifier();
-}
+StringRef InputFile::getName() const { return Mods[0].getModuleIdentifier(); }
 
 BitcodeModule &InputFile::getSingleBitcodeModule() {
   assert(Mods.size() == 1 && "Expect only one bitcode module");
@@ -900,8 +899,8 @@
       if (Res.FinalDefinitionInLinkageUnit) {
         GV->setDSOLocal(true);
         if (GV->hasDLLImportStorageClass())
-          GV->setDLLStorageClass(GlobalValue::DLLStorageClassTypes::
-                                 DefaultStorageClass);
+          GV->setDLLStorageClass(
+              GlobalValue::DLLStorageClassTypes::DefaultStorageClass);
       }
     } else if (auto *AS =
                    dyn_cast_if_present<ModuleSymbolTable::AsmSymbol *>(Msym)) {
@@ -1346,7 +1345,7 @@
 #undef HANDLE_LIBCALL
 };
 
-ArrayRef<const char*> LTO::getRuntimeLibcallSymbols() {
+ArrayRef<const char *> LTO::getRuntimeLibcallSymbols() {
   return ArrayRef(libcallRoutineNames);
 }
 
@@ -1412,7 +1411,7 @@
   std::set<GlobalValue::GUID> CfiFunctionDecls;
 
   std::optional<Error> Err;
-  std::mutex ErrMu;
+  llvm::mutex ErrMu;
 
   bool ShouldEmitIndexFiles;
 
@@ -1507,7 +1506,7 @@
               AddStream, Cache, Task, BM, CombinedIndex, ImportList, ExportList,
               ResolvedODR, DefinedGlobals, ModuleMap);
           if (E) {
-            std::unique_lock<std::mutex> L(ErrMu);
+            llvm::unique_lock<llvm::mutex> L(ErrMu);
             if (Err)
               Err = joinErrors(std::move(*Err), std::move(E));
             else
diff '--color=auto' -r -u llvm/llvm/lib/Support/CrashRecoveryContext.cpp build/llvm-src/llvm/lib/Support/CrashRecoveryContext.cpp
--- llvm/llvm/lib/Support/CrashRecoveryContext.cpp	2023-12-29 16:36:23.355555740 +0100
+++ build/llvm-src/llvm/lib/Support/CrashRecoveryContext.cpp	2024-01-02 03:15:13.632395297 +0100
@@ -7,6 +7,53 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/CrashRecoveryContext.h"
+
+#ifdef __wasi__
+
+namespace llvm {
+CrashRecoveryContextCleanup::~CrashRecoveryContextCleanup() = default;
+CrashRecoveryContext::CrashRecoveryContext() {
+  (void)Impl;
+  (void)head;
+}
+CrashRecoveryContext::~CrashRecoveryContext() {}
+
+void CrashRecoveryContext::registerCleanup(
+    CrashRecoveryContextCleanup *cleanup) {
+  cleanup->cleanupFired = true;
+  cleanup->recoverResources();
+  delete cleanup;
+}
+
+void CrashRecoveryContext::unregisterCleanup(
+    CrashRecoveryContextCleanup *cleanup) {}
+
+void CrashRecoveryContext::Enable() {}
+void CrashRecoveryContext::Disable() {}
+CrashRecoveryContext *CrashRecoveryContext::GetCurrent() { return nullptr; }
+bool CrashRecoveryContext::isRecoveringFromCrash() { return false; }
+
+bool CrashRecoveryContext::RunSafely(function_ref<void()> Fn) {
+  Fn();
+  return true;
+}
+
+bool CrashRecoveryContext::RunSafelyOnThread(function_ref<void()> Fn,
+                                             unsigned RequestedStackSize) {
+  return RunSafely(Fn);
+}
+
+[[noreturn]] void CrashRecoveryContext::HandleExit(int RetCode) {
+  exit(RetCode);
+}
+
+bool CrashRecoveryContext::isCrash(int RetCode) { return false; }
+bool CrashRecoveryContext::throwIfCrash(int RetCode) { return false; }
+
+} // namespace llvm
+
+#else
+
 #include "llvm/Config/llvm-config.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/ExitCodes.h"
@@ -118,7 +165,7 @@
   }
   IsRecoveringFromCrash = PC;
 
-  CrashRecoveryContextImpl *CRCI = (CrashRecoveryContextImpl *) Impl;
+  CrashRecoveryContextImpl *CRCI = (CrashRecoveryContextImpl *)Impl;
   delete CRCI;
 }
 
@@ -154,8 +201,8 @@
   uninstallExceptionOrSignalHandlers();
 }
 
-void CrashRecoveryContext::registerCleanup(CrashRecoveryContextCleanup *cleanup)
-{
+void CrashRecoveryContext::registerCleanup(
+    CrashRecoveryContextCleanup *cleanup) {
   if (!cleanup)
     return;
   if (head)
@@ -164,16 +211,15 @@
   head = cleanup;
 }
 
-void
-CrashRecoveryContext::unregisterCleanup(CrashRecoveryContextCleanup *cleanup) {
+void CrashRecoveryContext::unregisterCleanup(
+    CrashRecoveryContextCleanup *cleanup) {
   if (!cleanup)
     return;
   if (cleanup == head) {
     head = cleanup->next;
     if (head)
       head->prev = nullptr;
-  }
-  else {
+  } else {
     cleanup->prev->next = cleanup->next;
     if (cleanup->next)
       cleanup->next->prev = cleanup->prev;
@@ -263,16 +309,14 @@
 
 #include "llvm/Support/Windows/WindowsSupport.h"
 
-static LONG CALLBACK ExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)
-{
+static LONG CALLBACK ExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo) {
   // DBG_PRINTEXCEPTION_WIDE_C is not properly defined on all supported
   // compilers and platforms, so we define it manually.
   constexpr ULONG DbgPrintExceptionWideC = 0x4001000AL;
-  switch (ExceptionInfo->ExceptionRecord->ExceptionCode)
-  {
+  switch (ExceptionInfo->ExceptionRecord->ExceptionCode) {
   case DBG_PRINTEXCEPTION_C:
   case DbgPrintExceptionWideC:
-  case 0x406D1388:  // set debugger thread name
+  case 0x406D1388: // set debugger thread name
     return EXCEPTION_CONTINUE_EXECUTION;
   }
 
@@ -307,7 +351,7 @@
 // CrashRecoveryContext at all.  So we make use of a thread-local
 // exception table.  The handles contained in here will either be
 // non-NULL, valid VEH handles, or NULL.
-static LLVM_THREAD_LOCAL const void* sCurrentExceptionHandle;
+static LLVM_THREAD_LOCAL const void *sCurrentExceptionHandle;
 
 static void installExceptionOrSignalHandlers() {
   // We can set up vectored exception handling now.  We will install our
@@ -344,8 +388,8 @@
 
 #include <signal.h>
 
-static const int Signals[] =
-    { SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP };
+static const int Signals[] = {SIGABRT, SIGBUS,  SIGFPE,
+                              SIGILL,  SIGSEGV, SIGTRAP};
 static const unsigned NumSignals = std::size(Signals);
 static struct sigaction PrevActions[NumSignals];
 
@@ -502,7 +546,7 @@
 
 static void RunSafelyOnThread_Dispatch(void *UserData) {
   RunSafelyOnThreadInfo *Info =
-    reinterpret_cast<RunSafelyOnThreadInfo*>(UserData);
+      reinterpret_cast<RunSafelyOnThreadInfo *>(UserData);
 
   if (Info->UseBackgroundPriority)
     setThreadBackgroundPriority();
@@ -512,7 +556,7 @@
 bool CrashRecoveryContext::RunSafelyOnThread(function_ref<void()> Fn,
                                              unsigned RequestedStackSize) {
   bool UseBackgroundPriority = hasThreadBackgroundPriority();
-  RunSafelyOnThreadInfo Info = { Fn, this, UseBackgroundPriority, false };
+  RunSafelyOnThreadInfo Info = {Fn, this, UseBackgroundPriority, false};
   llvm::thread Thread(RequestedStackSize == 0
                           ? std::nullopt
                           : std::optional<unsigned>(RequestedStackSize),
@@ -523,3 +567,5 @@
     CRC->setSwitchedThread();
   return Info.Result;
 }
+
+#endif
diff '--color=auto' -r -u llvm/llvm/lib/Support/FileCollector.cpp build/llvm-src/llvm/lib/Support/FileCollector.cpp
--- llvm/llvm/lib/Support/FileCollector.cpp	2023-12-29 16:36:23.356555794 +0100
+++ build/llvm-src/llvm/lib/Support/FileCollector.cpp	2024-01-02 03:15:13.632395297 +0100
@@ -19,7 +19,7 @@
 FileCollectorBase::~FileCollectorBase() = default;
 
 void FileCollectorBase::addFile(const Twine &File) {
-  std::lock_guard<std::mutex> lock(Mutex);
+  llvm::lock_guard<llvm::mutex> lock(Mutex);
   std::string FileStr = File.str();
   if (markAsSeen(FileStr))
     addFileImpl(FileStr);
@@ -181,7 +181,7 @@
     return Err;
   }
 
-  std::lock_guard<std::mutex> lock(Mutex);
+  llvm::lock_guard<llvm::mutex> lock(Mutex);
 
   for (auto &entry : VFSWriter.getMappings()) {
     // Get the status of the original file/directory.
@@ -236,7 +236,7 @@
 }
 
 std::error_code FileCollector::writeMapping(StringRef MappingFile) {
-  std::lock_guard<std::mutex> lock(Mutex);
+  llvm::lock_guard<llvm::mutex> lock(Mutex);
 
   VFSWriter.setOverlayDir(OverlayRoot);
   VFSWriter.setCaseSensitivity(isCaseSensitivePath(OverlayRoot));
diff '--color=auto' -r -u llvm/llvm/lib/Support/LockFileManager.cpp build/llvm-src/llvm/lib/Support/LockFileManager.cpp
--- llvm/llvm/lib/Support/LockFileManager.cpp	2023-12-29 16:36:23.357555849 +0100
+++ build/llvm-src/llvm/lib/Support/LockFileManager.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -16,6 +16,7 @@
 #include "llvm/Support/Process.h"
 #include "llvm/Support/Signals.h"
 #include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/thread.h"
 #include <cerrno>
 #include <chrono>
 #include <ctime>
@@ -24,7 +25,6 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <system_error>
-#include <thread>
 #include <tuple>
 
 #ifdef _WIN32
@@ -34,7 +34,9 @@
 #include <unistd.h>
 #endif
 
-#if defined(__APPLE__) && defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1050)
+#if defined(__APPLE__) &&                                                      \
+    defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&                  \
+    (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ > 1050)
 #define USE_OSX_GETHOSTUUID 1
 #else
 #define USE_OSX_GETHOSTUUID 0
@@ -136,9 +138,10 @@
 class RemoveUniqueLockFileOnSignal {
   StringRef Filename;
   bool RemoveImmediately;
+
 public:
   RemoveUniqueLockFileOnSignal(StringRef Name)
-  : Filename(Name), RemoveImmediately(true) {
+      : Filename(Name), RemoveImmediately(true) {
     sys::RemoveFileOnSignal(Filename, nullptr);
   }
 
@@ -157,8 +160,7 @@
 
 } // end anonymous namespace
 
-LockFileManager::LockFileManager(StringRef FileName)
-{
+LockFileManager::LockFileManager(StringRef FileName) {
   this->FileName = FileName;
   if (std::error_code EC = sys::fs::make_absolute(this->FileName)) {
     std::string S("failed to obtain absolute path for ");
@@ -215,8 +217,7 @@
 
   while (true) {
     // Create a link from the lock file name. If this succeeds, we're done.
-    std::error_code EC =
-        sys::fs::create_link(UniqueLockFileName, LockFileName);
+    std::error_code EC = sys::fs::create_link(UniqueLockFileName, LockFileName);
     if (!EC) {
       RemoveUniqueFile.lockAcquired();
       return;
@@ -316,7 +317,7 @@
     std::uniform_int_distribution<unsigned long> Distribution(1,
                                                               WaitMultiplier);
     unsigned long WaitDurationMS = MinWaitDurationMS * Distribution(Engine);
-    std::this_thread::sleep_for(std::chrono::milliseconds(WaitDurationMS));
+    llvm::this_thread::sleep_for(std::chrono::milliseconds(WaitDurationMS));
 
     if (sys::fs::access(LockFileName.c_str(), sys::fs::AccessMode::Exist) ==
         errc::no_such_file_or_directory) {
diff '--color=auto' -r -u llvm/llvm/lib/Support/ManagedStatic.cpp build/llvm-src/llvm/lib/Support/ManagedStatic.cpp
--- llvm/llvm/lib/Support/ManagedStatic.cpp	2023-12-29 16:36:23.357555849 +0100
+++ build/llvm-src/llvm/lib/Support/ManagedStatic.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -13,22 +13,23 @@
 #include "llvm/Support/ManagedStatic.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 #include <cassert>
-#include <mutex>
+
 using namespace llvm;
 
 static const ManagedStaticBase *StaticList = nullptr;
 
-static std::recursive_mutex *getManagedStaticMutex() {
-  static std::recursive_mutex m;
+static llvm::recursive_mutex *getManagedStaticMutex() {
+  static llvm::recursive_mutex m;
   return &m;
 }
 
 void ManagedStaticBase::RegisterManagedStatic(void *(*Creator)(),
-                                              void (*Deleter)(void*)) const {
+                                              void (*Deleter)(void *)) const {
   assert(Creator);
   if (llvm_is_multithreaded()) {
-    std::lock_guard<std::recursive_mutex> Lock(*getManagedStaticMutex());
+    llvm::lock_guard<llvm::recursive_mutex> Lock(*getManagedStaticMutex());
 
     if (!Ptr.load(std::memory_order_relaxed)) {
       void *Tmp = Creator();
diff '--color=auto' -r -u llvm/llvm/lib/Support/Parallel.cpp build/llvm-src/llvm/lib/Support/Parallel.cpp
--- llvm/llvm/lib/Support/Parallel.cpp	2023-12-29 16:36:23.357555849 +0100
+++ build/llvm-src/llvm/lib/Support/Parallel.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -10,11 +10,10 @@
 #include "llvm/Config/llvm-config.h"
 #include "llvm/Support/ManagedStatic.h"
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 
 #include <atomic>
 #include <deque>
-#include <future>
-#include <thread>
 #include <vector>
 
 llvm::ThreadPoolStrategy llvm::parallel::strategy;
@@ -55,11 +54,11 @@
     // can take a while.
     Threads.reserve(ThreadCount);
     Threads.resize(1);
-    std::lock_guard<std::mutex> Lock(Mutex);
+    llvm::lock_guard<llvm::mutex> Lock(Mutex);
     // Use operator[] before creating the thread to avoid data race in .size()
     // in “safe libc++” mode.
     auto &Thread0 = Threads[0];
-    Thread0 = std::thread([this, S] {
+    Thread0 = llvm::thread([this, S] {
       for (unsigned I = 1; I < ThreadCount; ++I) {
         Threads.emplace_back([=] { work(S, I); });
         if (Stop)
@@ -72,7 +71,7 @@
 
   void stop() {
     {
-      std::lock_guard<std::mutex> Lock(Mutex);
+      llvm::lock_guard<llvm::mutex> Lock(Mutex);
       if (Stop)
         return;
       Stop = true;
@@ -83,8 +82,8 @@
 
   ~ThreadPoolExecutor() override {
     stop();
-    std::thread::id CurrentThreadId = std::this_thread::get_id();
-    for (std::thread &T : Threads)
+    llvm::thread::id CurrentThreadId = llvm::this_thread::get_id();
+    for (llvm::thread &T : Threads)
       if (T.get_id() == CurrentThreadId)
         T.detach();
       else
@@ -100,7 +99,7 @@
 
   void add(std::function<void()> F, bool Sequential = false) override {
     {
-      std::lock_guard<std::mutex> Lock(Mutex);
+      llvm::lock_guard<llvm::mutex> Lock(Mutex);
       if (Sequential)
         WorkQueueSequential.emplace_front(std::move(F));
       else
@@ -122,7 +121,7 @@
     threadIndex = ThreadID;
     S.apply_thread_strategy(ThreadID);
     while (true) {
-      std::unique_lock<std::mutex> Lock(Mutex);
+      llvm::unique_lock<llvm::mutex> Lock(Mutex);
       Cond.wait(Lock, [&] {
         return Stop || hasGeneralTasks() || hasSequentialTasks();
       });
@@ -148,10 +147,10 @@
   std::atomic<bool> SequentialQueueIsLocked{false};
   std::deque<std::function<void()>> WorkQueue;
   std::deque<std::function<void()>> WorkQueueSequential;
-  std::mutex Mutex;
-  std::condition_variable Cond;
-  std::promise<void> ThreadsCreated;
-  std::vector<std::thread> Threads;
+  llvm::mutex Mutex;
+  llvm::condition_variable Cond;
+  llvm::promise<void> ThreadsCreated;
+  std::vector<llvm::thread> Threads;
   unsigned ThreadCount;
 };
 
@@ -195,11 +194,12 @@
 TaskGroup::TaskGroup()
 #if LLVM_ENABLE_THREADS
     : Parallel((parallel::strategy.ThreadsRequested != 1) &&
-               (threadIndex == UINT_MAX)) {}
+               (threadIndex == UINT_MAX)){}
 #else
-    : Parallel(false) {}
+    : Parallel(false) {
+}
 #endif
-TaskGroup::~TaskGroup() {
+      TaskGroup::~TaskGroup() {
   // We must ensure that all the workloads have finished before decrementing the
   // instances count.
   L.sync();
diff '--color=auto' -r -u llvm/llvm/lib/Support/Process.cpp build/llvm-src/llvm/lib/Support/Process.cpp
--- llvm/llvm/lib/Support/Process.cpp	2023-12-29 16:36:23.358555904 +0100
+++ build/llvm-src/llvm/lib/Support/Process.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -67,24 +67,18 @@
   return FoundPath;
 }
 
-
 #define COLOR(FGBG, CODE, BOLD) "\033[0;" BOLD FGBG CODE "m"
 
-#define ALLCOLORS(FGBG,BOLD) {\
-    COLOR(FGBG, "0", BOLD),\
-    COLOR(FGBG, "1", BOLD),\
-    COLOR(FGBG, "2", BOLD),\
-    COLOR(FGBG, "3", BOLD),\
-    COLOR(FGBG, "4", BOLD),\
-    COLOR(FGBG, "5", BOLD),\
-    COLOR(FGBG, "6", BOLD),\
-    COLOR(FGBG, "7", BOLD)\
+#define ALLCOLORS(FGBG, BOLD)                                                  \
+  {                                                                            \
+    COLOR(FGBG, "0", BOLD), COLOR(FGBG, "1", BOLD), COLOR(FGBG, "2", BOLD),    \
+        COLOR(FGBG, "3", BOLD), COLOR(FGBG, "4", BOLD),                        \
+        COLOR(FGBG, "5", BOLD), COLOR(FGBG, "6", BOLD), COLOR(FGBG, "7", BOLD) \
   }
 
 static const char colorcodes[2][2][8][10] = {
- { ALLCOLORS("3",""), ALLCOLORS("3","1;") },
- { ALLCOLORS("4",""), ALLCOLORS("4","1;") }
-};
+    {ALLCOLORS("3", ""), ALLCOLORS("3", "1;")},
+    {ALLCOLORS("4", ""), ALLCOLORS("4", "1;")}};
 
 // A CMake option controls wheter we emit core dumps by default. An application
 // may disable core dumps by calling Process::PreventCoreFiles().
diff '--color=auto' -r -u llvm/llvm/lib/Support/TimeProfiler.cpp build/llvm-src/llvm/lib/Support/TimeProfiler.cpp
--- llvm/llvm/lib/Support/TimeProfiler.cpp	2023-12-29 16:36:23.359555960 +0100
+++ build/llvm-src/llvm/lib/Support/TimeProfiler.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -17,6 +17,7 @@
 #include "llvm/Support/Path.h"
 #include "llvm/Support/Process.h"
 #include "llvm/Support/Threading.h"
+#include "llvm/Support/thread.h"
 #include <algorithm>
 #include <cassert>
 #include <chrono>
@@ -37,7 +38,7 @@
 using std::chrono::time_point_cast;
 
 struct TimeTraceProfilerInstances {
-  std::mutex Lock;
+  llvm::mutex Lock;
   std::vector<TimeTraceProfiler *> List;
 };
 
@@ -148,7 +149,7 @@
   void write(raw_pwrite_stream &OS) {
     // Acquire Mutex as reading ThreadTimeTraceProfilerInstances.
     auto &Instances = getTimeTraceProfilerInstances();
-    std::lock_guard<std::mutex> Lock(Instances.Lock);
+    llvm::lock_guard<llvm::mutex> Lock(Instances.Lock);
     assert(Stack.empty() &&
            "All profiler sections should be ended when calling write");
     assert(llvm::all_of(Instances.List,
@@ -300,7 +301,7 @@
   TimeTraceProfilerInstance = nullptr;
 
   auto &Instances = getTimeTraceProfilerInstances();
-  std::lock_guard<std::mutex> Lock(Instances.Lock);
+  llvm::lock_guard<llvm::mutex> Lock(Instances.Lock);
   for (auto *TTP : Instances.List)
     delete TTP;
   Instances.List.clear();
@@ -310,7 +311,7 @@
 // This doesn't remove the instance, just moves the pointer to global vector.
 void llvm::timeTraceProfilerFinishThread() {
   auto &Instances = getTimeTraceProfilerInstances();
-  std::lock_guard<std::mutex> Lock(Instances.Lock);
+  llvm::lock_guard<llvm::mutex> Lock(Instances.Lock);
   Instances.List.push_back(TimeTraceProfilerInstance);
   TimeTraceProfilerInstance = nullptr;
 }
diff '--color=auto' -r -u llvm/llvm/lib/Support/Unix/Path.inc build/llvm-src/llvm/lib/Support/Unix/Path.inc
--- llvm/llvm/lib/Support/Unix/Path.inc	2023-12-29 21:47:41.896675722 +0100
+++ build/llvm-src/llvm/lib/Support/Unix/Path.inc	2024-01-02 03:15:13.633395352 +0100
@@ -191,7 +191,9 @@
 /// GetMainExecutable - Return the path to the main executable, given the
 /// value of argv[0] from program startup.
 std::string getMainExecutable(const char *argv0, void *MainAddr) {
-#if defined(__APPLE__)
+#if defined(__wasi__)
+  return argv0;
+#elif defined(__APPLE__)
   // On OS X the executable path is saved to the stack by dyld. Reading it
   // from there is much faster than calling dladdr, especially for large
   // binaries with symbols.
@@ -505,7 +507,7 @@
 #elif defined(__Fuchsia__)
   // Fuchsia doesn't yet support remote filesystem mounts.
   return true;
-#elif defined(__EMSCRIPTEN__)
+#elif defined(__EMSCRIPTEN__) || defined(__wasi__)
   // Emscripten doesn't currently support remote filesystem mounts.
   return true;
 #elif defined(__HAIKU__)
@@ -920,7 +922,7 @@
   // Note that while glibc provides a macro to see if this is supported,
   // _DIRENT_HAVE_D_TYPE, it's not defined on BSD/Mac, so we test for the
   // d_type-to-mode_t conversion macro instead.
-#if defined(DTTOIF)
+#if defined(DTTOIF) && !defined(__wasi__)
   return typeForMode(DTTOIF(Entry->d_type));
 #else
   // Other platforms such as Solaris require a stat() to get the type.
@@ -1215,6 +1217,9 @@
 }
 
 std::error_code tryLockFile(int FD, std::chrono::milliseconds Timeout) {
+#if defined(__wasi__)
+  return std::error_code();
+#else
   auto Start = std::chrono::steady_clock::now();
   auto End = Start + Timeout;
   do {
@@ -1232,9 +1237,13 @@
     usleep(1000);
   } while (std::chrono::steady_clock::now() < End);
   return make_error_code(errc::no_lock_available);
+#endif
 }
 
 std::error_code lockFile(int FD) {
+#if defined(__wasi__)
+  return std::error_code();
+#else
   struct flock Lock;
   memset(&Lock, 0, sizeof(Lock));
   Lock.l_type = F_WRLCK;
@@ -1245,9 +1254,13 @@
     return std::error_code();
   int Error = errno;
   return std::error_code(Error, std::generic_category());
+#endif
 }
 
 std::error_code unlockFile(int FD) {
+#if defined(__wasi__)
+  return std::error_code();
+#else
   struct flock Lock;
   Lock.l_type = F_UNLCK;
   Lock.l_whence = SEEK_SET;
@@ -1256,6 +1269,7 @@
   if (::fcntl(FD, F_SETLK, &Lock) != -1)
     return std::error_code();
   return std::error_code(errno, std::generic_category());
+#endif
 }
 
 std::error_code closeFile(file_t &F) {
diff '--color=auto' -r -u llvm/llvm/lib/Support/Unix/Program.inc build/llvm-src/llvm/lib/Support/Unix/Program.inc
--- llvm/llvm/lib/Support/Unix/Program.inc	2023-12-29 21:47:41.897675778 +0100
+++ build/llvm-src/llvm/lib/Support/Unix/Program.inc	2024-01-02 03:15:13.633395352 +0100
@@ -177,6 +177,9 @@
                     ArrayRef<std::optional<StringRef>> Redirects,
                     unsigned MemoryLimit, std::string *ErrMsg,
                     BitVector *AffinityMask) {
+#ifdef __wasi__
+  return false;
+#else
   if (!llvm::sys::fs::exists(Program)) {
     if (ErrMsg)
       *ErrMsg = std::string("Executable \"") + Program.str() +
@@ -337,6 +340,7 @@
   PI.Process = child;
 
   return true;
+#endif
 }
 
 namespace llvm {
@@ -390,6 +394,7 @@
                             std::string *ErrMsg,
                             std::optional<ProcessStatistics> *ProcStat,
                             bool Polling) {
+#ifndef __wasi__
   struct sigaction Act, Old;
   assert(PI.Pid && "invalid pid to wait on, process not started?");
 
@@ -506,6 +511,11 @@
     // signal during execution as opposed to failing to execute.
     WaitResult.ReturnCode = -2;
   }
+#else
+  ProcessInfo WaitResult;
+  WaitResult.Pid = 23456;
+  WaitResult.ReturnCode = -1;
+#endif
   return WaitResult;
 }
 
diff '--color=auto' -r -u llvm/llvm/lib/Transforms/CMakeLists.txt build/llvm-src/llvm/lib/Transforms/CMakeLists.txt
--- llvm/llvm/lib/Transforms/CMakeLists.txt	2023-12-29 16:36:23.625570600 +0100
+++ build/llvm-src/llvm/lib/Transforms/CMakeLists.txt	2024-01-02 03:15:13.633395352 +0100
@@ -5,7 +5,9 @@
 add_subdirectory(Scalar)
 add_subdirectory(IPO)
 add_subdirectory(Vectorize)
+if (NOT WASI)
 add_subdirectory(Hello)
+endif ()
 add_subdirectory(ObjCARC)
 add_subdirectory(Coroutines)
 add_subdirectory(CFGuard)
diff '--color=auto' -r -u llvm/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp build/llvm-src/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
--- llvm/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp	2023-12-29 16:36:23.644571646 +0100
+++ build/llvm-src/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp	2024-01-02 03:15:13.633395352 +0100
@@ -29,8 +29,7 @@
 
 static cl::opt<std::string> ClOrderFileWriteMapping(
     "orderfile-write-mapping", cl::init(""),
-    cl::desc(
-        "Dump functions and their MD5 hash to deobfuscate profile data"),
+    cl::desc("Dump functions and their MD5 hash to deobfuscate profile data"),
     cl::Hidden);
 
 namespace {
@@ -40,7 +39,7 @@
 // fixed-size buffer that saves the MD5 hash of the function. We need
 // a global variable to save the index into the buffer.
 
-std::mutex MappingMutex;
+llvm::mutex MappingMutex;
 
 struct InstrOrderFile {
 private:
@@ -68,14 +67,16 @@
 
     // Create the global variables.
     std::string SymbolName = INSTR_PROF_ORDERFILE_BUFFER_NAME_STR;
-    OrderFileBuffer = new GlobalVariable(M, BufferTy, false, GlobalValue::LinkOnceODRLinkage,
+    OrderFileBuffer =
+        new GlobalVariable(M, BufferTy, false, GlobalValue::LinkOnceODRLinkage,
                            Constant::getNullValue(BufferTy), SymbolName);
     Triple TT = Triple(M.getTargetTriple());
     OrderFileBuffer->setSection(
         getInstrProfSectionName(IPSK_orderfile, TT.getObjectFormat()));
 
     std::string IndexName = INSTR_PROF_ORDERFILE_BUFFER_IDX_NAME_STR;
-    BufferIdx = new GlobalVariable(M, IdxTy, false, GlobalValue::LinkOnceODRLinkage,
+    BufferIdx =
+        new GlobalVariable(M, IdxTy, false, GlobalValue::LinkOnceODRLinkage,
                            Constant::getNullValue(IdxTy), IndexName);
 
     std::string BitMapName = "bitmap_0";
@@ -87,18 +88,19 @@
   // update the buffer.
   void generateCodeSequence(Module &M, Function &F, int FuncId) {
     if (!ClOrderFileWriteMapping.empty()) {
-      std::lock_guard<std::mutex> LogLock(MappingMutex);
+      llvm::lock_guard<llvm::mutex> LogLock(MappingMutex);
       std::error_code EC;
       llvm::raw_fd_ostream OS(ClOrderFileWriteMapping, EC,
                               llvm::sys::fs::OF_Append);
       if (EC) {
-        report_fatal_error(Twine("Failed to open ") + ClOrderFileWriteMapping +
-                           " to save mapping file for order file instrumentation\n");
+        report_fatal_error(
+            Twine("Failed to open ") + ClOrderFileWriteMapping +
+            " to save mapping file for order file instrumentation\n");
       } else {
         std::stringstream stream;
         stream << std::hex << MD5Hash(F.getName());
-        std::string singleLine = "MD5 " + stream.str() + " " +
-                                 std::string(F.getName()) + '\n';
+        std::string singleLine =
+            "MD5 " + stream.str() + " " + std::string(F.getName()) + '\n';
         OS << singleLine;
       }
     }
@@ -140,8 +142,9 @@
     Value *BufferGEPIdx[] = {ConstantInt::get(Int32Ty, 0), WrappedIdx};
     Value *BufferAddr =
         updateB.CreateGEP(BufferTy, OrderFileBuffer, BufferGEPIdx, "");
-    updateB.CreateStore(ConstantInt::get(Type::getInt64Ty(Ctx), MD5Hash(F.getName())),
-                        BufferAddr);
+    updateB.CreateStore(
+        ConstantInt::get(Type::getInt64Ty(Ctx), MD5Hash(F.getName())),
+        BufferAddr);
     updateB.CreateBr(OrigEntry);
   }
 
@@ -162,8 +165,8 @@
 }; // End of InstrOrderFile struct
 } // End anonymous namespace
 
-PreservedAnalyses
-InstrOrderFilePass::run(Module &M, ModuleAnalysisManager &AM) {
+PreservedAnalyses InstrOrderFilePass::run(Module &M,
+                                          ModuleAnalysisManager &AM) {
   if (InstrOrderFile().run(M))
     return PreservedAnalyses::none();
   return PreservedAnalyses::all();
diff '--color=auto' -r -u llvm/llvm/tools/CMakeLists.txt build/llvm-src/llvm/tools/CMakeLists.txt
--- llvm/llvm/tools/CMakeLists.txt	2023-12-29 16:36:26.139708973 +0100
+++ build/llvm-src/llvm/tools/CMakeLists.txt	2024-01-02 03:15:13.633395352 +0100
@@ -28,18 +28,23 @@
 # Add LTO, llvm-ar, llvm-config, and llvm-profdata before clang, ExternalProject
 # requires targets specified in DEPENDS to exist before the call to
 # ExternalProject_Add.
+if (NOT WASI)
 add_llvm_tool_subdirectory(lto)
 add_llvm_tool_subdirectory(gold)
 add_llvm_tool_subdirectory(llvm-ar)
 add_llvm_tool_subdirectory(llvm-config)
 add_llvm_tool_subdirectory(llvm-lto)
 add_llvm_tool_subdirectory(llvm-profdata)
+endif ()
 
 # Projects supported via LLVM_EXTERNAL_*_SOURCE_DIR need to be explicitly
 # specified.
 add_llvm_external_project(clang)
 add_llvm_external_project(lld)
+
+if (NOT WASI)
 add_llvm_external_project(lldb)
+
 add_llvm_external_project(mlir)
 # Flang depends on mlir, so place it afterward
 add_llvm_external_project(flang)
@@ -50,6 +55,7 @@
 add_llvm_implicit_projects()
 
 add_llvm_external_project(polly)
+endif ()
 
 # Add subprojects specified using LLVM_EXTERNAL_PROJECTS
 foreach(p ${LLVM_EXTERNAL_PROJECTS})
